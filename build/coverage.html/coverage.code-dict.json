{"/home/travis/build/npmtest/node-npmtest-grunt-ts/test.js":"/* istanbul instrument in package npmtest_grunt_ts */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-grunt-ts/lib.npmtest_grunt_ts.js":"/* istanbul instrument in package npmtest_grunt_ts */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_grunt_ts = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_grunt_ts = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-grunt-ts/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-grunt-ts && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_grunt_ts */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_grunt_ts\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_grunt_ts.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_grunt_ts.rollup.js'] =\n            local.assetsDict['/assets.npmtest_grunt_ts.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_grunt_ts.__dirname + '/lib.npmtest_grunt_ts.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-grunt-ts/node_modules/grunt-ts/tasks/ts.js":"/// <reference path=\"../defs/tsd.d.ts\"/>\r\n/// <reference path=\"./modules/interfaces.d.ts\"/>\r\n'use strict';\r\n/*\r\n * grunt-ts\r\n * Licensed under the MIT license.\r\n */\r\nvar _ = require('lodash');\r\nvar path = require('path');\r\nvar fs = require('fs');\r\nvar es6_promise_1 = require('es6-promise');\r\nvar utils = require('./modules/utils');\r\nvar compileModule = require('./modules/compile');\r\nvar referenceModule = require('./modules/reference');\r\nvar amdLoaderModule = require('./modules/amdLoader');\r\nvar html2tsModule = require('./modules/html2ts');\r\nvar templateCacheModule = require('./modules/templateCache');\r\nvar transformers = require('./modules/transformers');\r\nvar optionsResolver = require('../tasks/modules/optionsResolver');\r\nvar asyncSeries = utils.asyncSeries, timeIt = utils.timeIt;\r\nvar fail_event = 'grunt-ts.failure';\r\nfunction pluginFn(grunt) {\r\n    /////////////////////////////////////////////////////////////////////\r\n    // The grunt task\r\n    ////////////////////////////////////////////////////////////////////\r\n    grunt.registerMultiTask('ts', 'Compile TypeScript files', function () {\r\n        // tracks which index in the task \"files\" property is next for processing\r\n        var filesCompilationIndex = 0;\r\n        var done, options;\r\n        {\r\n            var currentGruntTask = this;\r\n            var resolvedFiles = currentGruntTask.files;\r\n            // make async\r\n            done = currentGruntTask.async();\r\n            // get unprocessed templates from configuration\r\n            var rawTaskConfig = (grunt.config.getRaw(currentGruntTask.name) || {});\r\n            var rawTargetConfig = (grunt.config.getRaw(currentGruntTask.name + '.' + currentGruntTask.target) || {});\r\n            optionsResolver.resolveAsync(rawTaskConfig, rawTargetConfig, currentGruntTask.target, resolvedFiles, grunt.template.process, grunt.file.expand).then(function (result) {\r\n                options = result;\r\n                options.warnings.forEach(function (warning) {\r\n                    grunt.log.writeln(warning.magenta);\r\n                });\r\n                options.errors.forEach(function (error) {\r\n                    grunt.log.writeln(error.red);\r\n                });\r\n                if (options.errors.length > 0) {\r\n                    if (options.emitGruntEvents) {\r\n                        grunt.event.emit(fail_event);\r\n                    }\r\n                    done(false);\r\n                    return;\r\n                }\r\n                proceed();\r\n            }).catch(function (error) {\r\n                grunt.log.writeln((error + '').red);\r\n                done(false);\r\n            });\r\n        }\r\n        function proceed() {\r\n            var srcFromVS_RelativePathsFromGruntFile = [];\r\n            // Run compiler\r\n            asyncSeries(options.CompilationTasks, function (currentFiles) {\r\n                // Create a reference file?\r\n                var reference = processIndividualTemplate(options.reference);\r\n                var referenceFile;\r\n                var referencePath;\r\n                if (!!reference) {\r\n                    referenceFile = path.resolve(reference);\r\n                    referencePath = path.dirname(referenceFile);\r\n                }\r\n                function isReferenceFile(filename) {\r\n                    return path.resolve(filename) === referenceFile;\r\n                }\r\n                // Create an output file?\r\n                var outFile = currentFiles.out;\r\n                var outFile_d_ts;\r\n                if (!!outFile) {\r\n                    outFile = path.resolve(outFile);\r\n                    outFile_d_ts = outFile.replace('.js', '.d.ts');\r\n                }\r\n                function isOutFile(filename) {\r\n                    return path.resolve(filename) === outFile_d_ts;\r\n                }\r\n                // see https://github.com/grunt-ts/grunt-ts/issues/77\r\n                function isBaseDirFile(filename, targetFiles) {\r\n                    var baseDirFile = '.baseDir.ts';\r\n                    var bd = '';\r\n                    if (!options.baseDir) {\r\n                        bd = utils.findCommonPath(targetFiles, '/');\r\n                        options.baseDir = bd;\r\n                    }\r\n                    return path.resolve(filename) === path.resolve(path.join(bd, baseDirFile));\r\n                }\r\n                // Create an amd loader?\r\n                var amdloader = options.amdloader;\r\n                var amdloaderFile, amdloaderPath;\r\n                if (!!amdloader) {\r\n                    amdloaderFile = path.resolve(amdloader);\r\n                    amdloaderPath = path.dirname(amdloaderFile);\r\n                }\r\n                // Compiles all the files\r\n                // Uses the blind tsc compile task\r\n                // logs errors\r\n                function runCompilation(options, compilationInfo) {\r\n                    grunt.log.writeln('Compiling...'.yellow);\r\n                    // Time the compiler process\r\n                    var starttime = new Date().getTime();\r\n                    var endtime;\r\n                    // Compile the files\r\n                    return compileModule.compileAllFiles(options, compilationInfo)\r\n                        .then(function (result) {\r\n                        // End the timer\r\n                        endtime = new Date().getTime();\r\n                        grunt.log.writeln('');\r\n                        // Analyze the results of our tsc execution,\r\n                        //   then tell the user our analysis results\r\n                        //   and mark the build as fail or success\r\n                        if (!result) {\r\n                            grunt.log.error('Error: No result from tsc.'.red);\r\n                            return false;\r\n                        }\r\n                        if (result.code === 8) {\r\n                            grunt.log.error('Error: Node was unable to run tsc.  Possibly it could not be found?'.red);\r\n                            return false;\r\n                        }\r\n                        // In TypeScript 1.3 and above, the result code corresponds to the ExitCode enum in\r\n                        //   TypeScript/src/compiler/sys.ts\r\n                        var isError = (result.code !== 0);\r\n                        // If the compilation errors contain only type errors, JS files are still\r\n                        //   generated. If tsc finds type errors, it will return an error code, even\r\n                        //   if JS files are generated. We should check this for this,\r\n                        //   only type errors, and call this a successful compilation.\r\n                        // Assumptions:\r\n                        //   Level 1 errors = syntax errors - prevent JS emit.\r\n                        //   Level 2 errors = semantic errors - *not* prevents JS emit.\r\n                        //   Level 5 errors = compiler flag misuse - prevents JS emit.\r\n                        var level1ErrorCount = 0, level5ErrorCount = 0, nonEmitPreventingWarningCount = 0;\r\n                        var hasTS7017Error = false;\r\n                        var hasPreventEmitErrors = _.foldl(result.output.split('\\n'), function (memo, errorMsg) {\r\n                            var isPreventEmitError = false;\r\n                            if (errorMsg.search(/error TS7017:/g) >= 0) {\r\n                                hasTS7017Error = true;\r\n                            }\r\n                            if (errorMsg.search(/error TS1\\d+:/g) >= 0) {\r\n                                level1ErrorCount += 1;\r\n                                isPreventEmitError = true;\r\n                            }\r\n                            else if (errorMsg.search(/error TS5\\d+:/) >= 0) {\r\n                                level5ErrorCount += 1;\r\n                                isPreventEmitError = true;\r\n                            }\r\n                            else if (errorMsg.search(/error TS\\d+:/) >= 0) {\r\n                                nonEmitPreventingWarningCount += 1;\r\n                            }\r\n                            return memo || isPreventEmitError;\r\n                        }, false) || false;\r\n                        // Because we can't think of a better way to determine it,\r\n                        //   assume that emitted JS in spite of error codes implies type-only errors.\r\n                        var isOnlyTypeErrors = !hasPreventEmitErrors;\r\n                        if (hasTS7017Error) {\r\n                            grunt.log.writeln(('Note:  You may wish to enable the suppressImplicitAnyIndexErrors' +\r\n                                ' grunt-ts option to allow dynamic property access by index.  This will' +\r\n                                ' suppress TypeScript error TS7017.').magenta);\r\n                        }\r\n                        // Log error summary\r\n                        if (level1ErrorCount + level5ErrorCount + nonEmitPreventingWarningCount > 0) {\r\n                            if ((level1ErrorCount + level5ErrorCount > 0) || options.failOnTypeErrors) {\r\n                                grunt.log.write(('>> ').red);\r\n                            }\r\n                            else {\r\n                                grunt.log.write(('>> ').green);\r\n                            }\r\n                            if (level5ErrorCount > 0) {\r\n                                grunt.log.write(level5ErrorCount.toString() + ' compiler flag error' +\r\n                                    (level5ErrorCount === 1 ? '' : 's') + '  ');\r\n                            }\r\n                            if (level1ErrorCount > 0) {\r\n                                grunt.log.write(level1ErrorCount.toString() + ' syntax error' +\r\n                                    (level1ErrorCount === 1 ? '' : 's') + '  ');\r\n                            }\r\n                            if (nonEmitPreventingWarningCount > 0) {\r\n                                grunt.log.write(nonEmitPreventingWarningCount.toString() +\r\n                                    ' non-emit-preventing type warning' +\r\n                                    (nonEmitPreventingWarningCount === 1 ? '' : 's') + '  ');\r\n                            }\r\n                            grunt.log.writeln('');\r\n                            if (isOnlyTypeErrors && !options.failOnTypeErrors) {\r\n                                grunt.log.write(('>> ').green);\r\n                                grunt.log.writeln('Type errors only.');\r\n                            }\r\n                        }\r\n                        // !!! To do: To really be confident that the build was actually successful,\r\n                        //   we have to check timestamps of the generated files in the destination.\r\n                        var isSuccessfulBuild = (!isError ||\r\n                            (isError && isOnlyTypeErrors && !options.failOnTypeErrors));\r\n                        if (isSuccessfulBuild) {\r\n                            // Report successful build.\r\n                            var time = (endtime - starttime) / 1000;\r\n                            grunt.log.writeln('');\r\n                            var message = 'TypeScript compilation complete: ' + time.toFixed(2) + 's';\r\n                            if (utils.shouldPassThrough(options)) {\r\n                                message += ' for TypeScript pass-through.';\r\n                            }\r\n                            else {\r\n                                message += ' for ' + result.fileCount + ' TypeScript files.';\r\n                            }\r\n                            grunt.log.writeln(message.green);\r\n                        }\r\n                        else {\r\n                            // Report unsuccessful build.\r\n                            grunt.log.error(('Error: tsc return code: ' + result.code).yellow);\r\n                        }\r\n                        return isSuccessfulBuild;\r\n                    }).catch(function (err) {\r\n                        grunt.log.writeln(('Error: ' + err).red);\r\n                        if (options.emitGruntEvents) {\r\n                            grunt.event.emit(fail_event);\r\n                        }\r\n                        return false;\r\n                    });\r\n                }\r\n                // Find out which files to compile, codegen etc.\r\n                // Then calls the appropriate functions + compile function on those files\r\n                function filterFilesTransformAndCompile() {\r\n                    var filesToCompile = [];\r\n                    if (currentFiles.src || options.vs) {\r\n                        _.map(currentFiles.src, function (file) {\r\n                            if (filesToCompile.indexOf(file) === -1) {\r\n                                filesToCompile.push(file);\r\n                            }\r\n                        });\r\n                        _.map(srcFromVS_RelativePathsFromGruntFile, function (file) {\r\n                            if (filesToCompile.indexOf(file) === -1) {\r\n                                filesToCompile.push(file);\r\n                            }\r\n                        });\r\n                    }\r\n                    else {\r\n                        filesCompilationIndex += 1;\r\n                    }\r\n                    // ignore directories, and clear the files of output.d.ts and baseDirFile\r\n                    filesToCompile = filesToCompile.filter(function (file) {\r\n                        var stats = fs.lstatSync(file);\r\n                        return !stats.isDirectory() && !isOutFile(file) && !isBaseDirFile(file, filesToCompile);\r\n                    });\r\n                    ///// Html files:\r\n                    // Note:\r\n                    //    compile html files must be before reference file creation\r\n                    var generatedFiles = [];\r\n                    if (options.html) {\r\n                        var html2tsOptions_1 = {\r\n                            moduleFunction: _.template(options.htmlModuleTemplate),\r\n                            varFunction: _.template(options.htmlVarTemplate),\r\n                            htmlOutputTemplate: options.htmlOutputTemplate,\r\n                            htmlOutDir: options.htmlOutDir,\r\n                            flatten: options.htmlOutDirFlatten,\r\n                            eol: (options.newLine || utils.eol)\r\n                        };\r\n                        var htmlFiles = grunt.file.expand(options.html);\r\n                        generatedFiles = _.map(htmlFiles, function (filename) { return html2tsModule.compileHTML(filename, html2tsOptions_1); });\r\n                        generatedFiles.forEach(function (fileName) {\r\n                            if (filesToCompile.indexOf(fileName) === -1 &&\r\n                                grunt.file.isMatch(currentFiles.glob, fileName)) {\r\n                                filesToCompile.push(fileName);\r\n                            }\r\n                        });\r\n                    }\r\n                    ///// Template cache\r\n                    // Note: The template cache files do not go into generated files.\r\n                    // Note: You are free to generate a `ts OR js` file for template cache, both should just work\r\n                    if (options.templateCache) {\r\n                        if (!options.templateCache.src || !options.templateCache.dest || !options.templateCache.baseUrl) {\r\n                            grunt.log.writeln('templateCache : src, dest, baseUrl must be specified if templateCache option is used'.red);\r\n                        }\r\n                        else {\r\n                            var templateCacheSrc = grunt.file.expand(options.templateCache.src); // manual reinterpolation\r\n                            var templateCacheDest = path.resolve(options.templateCache.dest);\r\n                            var templateCacheBasePath = path.resolve(options.templateCache.baseUrl);\r\n                            templateCacheModule.generateTemplateCache(templateCacheSrc, templateCacheDest, templateCacheBasePath, (options.newLine || utils.eol));\r\n                        }\r\n                    }\r\n                    ///// Reference File\r\n                    // Generate the reference file\r\n                    // Create a reference file if specified\r\n                    if (!!referencePath) {\r\n                        var result = timeIt(function () {\r\n                            return referenceModule.updateReferenceFile(filesToCompile.filter(function (f) { return !isReferenceFile(f); }), generatedFiles, referenceFile, referencePath, (options.newLine || utils.eol));\r\n                        });\r\n                        if (result.it === true) {\r\n                            grunt.log.writeln(('Updated reference file (' + result.time + 'ms).').green);\r\n                        }\r\n                    }\r\n                    ///// AMD loader\r\n                    // Create the amdLoader if specified\r\n                    if (!!amdloaderPath) {\r\n                        var referenceOrder = amdLoaderModule.getReferencesInOrder(referenceFile, referencePath, generatedFiles);\r\n                        amdLoaderModule.updateAmdLoader(referenceFile, referenceOrder, amdloaderFile, amdloaderPath, currentFiles.outDir);\r\n                    }\r\n                    // Transform files as needed. Currently all of this logic in is one module\r\n                    transformers.transformFiles(filesToCompile /*TODO: only unchanged files*/, filesToCompile, options);\r\n                    currentFiles.src = filesToCompile;\r\n                    // Return promise to compliation\r\n                    if (utils.shouldCompile(options)) {\r\n                        if (filesToCompile.length > 0 || options.testExecute || utils.shouldPassThrough(options)) {\r\n                            return runCompilation(options, currentFiles).then(function (success) {\r\n                                return success;\r\n                            });\r\n                        }\r\n                        else {\r\n                            // Nothing to do\r\n                            grunt.log.writeln('No files to compile'.red);\r\n                            return es6_promise_1.Promise.resolve(true);\r\n                        }\r\n                    }\r\n                    else {\r\n                        return es6_promise_1.Promise.resolve(true);\r\n                    }\r\n                }\r\n                // Time (in ms) when last compile took place\r\n                var lastCompile = 0;\r\n                // Watch a folder?\r\n                if (!!options.watch) {\r\n                    // get path(s)\r\n                    var watchpath = grunt.file.expand([options.watch]);\r\n                    // create a file watcher for path\r\n                    var chokidar = require('chokidar');\r\n                    var watcher = chokidar.watch(watchpath, { ignoreInitial: true, persistent: true });\r\n                    // Log what we are doing\r\n                    grunt.log.writeln(('Watching all TypeScript / Html files under : ' + watchpath).cyan);\r\n                    // A file has been added/changed/deleted has occurred\r\n                    watcher\r\n                        .on('add', function (path) {\r\n                        handleFileEvent(path, '+++ added   ', true);\r\n                        // Reset the time for last compile call\r\n                        lastCompile = new Date().getTime();\r\n                    })\r\n                        .on('change', function (path) {\r\n                        handleFileEvent(path, '### changed ', true);\r\n                        // Reset the time for last compile call\r\n                        lastCompile = new Date().getTime();\r\n                    })\r\n                        .on('unlink', function (path) {\r\n                        handleFileEvent(path, '--- removed ');\r\n                        // Reset the time for last compile call\r\n                        lastCompile = new Date().getTime();\r\n                    })\r\n                        .on('error', function (error) {\r\n                        console.error('Error happened in chokidar: ', error);\r\n                    });\r\n                }\r\n                // Reset the time for last compile call\r\n                lastCompile = new Date().getTime();\r\n                // Run initial compile\r\n                return filterFilesTransformAndCompile();\r\n                // local event to handle file event\r\n                function handleFileEvent(filepath, displaystr, addedOrChanged) {\r\n                    if (addedOrChanged === void 0) { addedOrChanged = false; }\r\n                    // Only ts and html :\r\n                    if (!utils.endsWith(filepath.toLowerCase(), '.ts') && !utils.endsWith(filepath.toLowerCase(), '.html')) {\r\n                        return;\r\n                    }\r\n                    // Do not run if just ran, behaviour same as grunt-watch\r\n                    // These are the files our run modified\r\n                    if ((new Date().getTime() - lastCompile) <= 100) {\r\n                        // Uncomment for debugging which files were ignored\r\n                        // grunt.log.writeln((' ///'  + ' >>' + filepath).grey);\r\n                        return;\r\n                    }\r\n                    // Log and run the debounced version.\r\n                    grunt.log.writeln((displaystr + ' >>' + filepath).yellow);\r\n                    filterFilesTransformAndCompile();\r\n                }\r\n            }).then(function (res) {\r\n                // Ignore res? (either logs or throws)\r\n                if (!options.watch) {\r\n                    if (res.some(function (success) {\r\n                        return !success;\r\n                    })) {\r\n                        if (options.emitGruntEvents) {\r\n                            grunt.event.emit(fail_event);\r\n                        }\r\n                        done(false);\r\n                    }\r\n                    else {\r\n                        done();\r\n                    }\r\n                }\r\n            }, done);\r\n        }\r\n    });\r\n    function processIndividualTemplate(template) {\r\n        if (template) {\r\n            return grunt.template.process(template, {});\r\n        }\r\n        return template;\r\n    }\r\n}\r\nmodule.exports = pluginFn;\r\n//# sourceMappingURL=ts.js.map","/home/travis/build/npmtest/node-npmtest-grunt-ts/node_modules/grunt-ts/tasks/modules/utils.js":"/// <reference path=\"../../defs/tsd.d.ts\"/>\r\n\"use strict\";\r\nvar path = require('path');\r\nvar fs = require('fs');\r\nvar os = require('os');\r\nvar util = require('util');\r\nvar _ = require('lodash');\r\nvar es6_promise_1 = require('es6-promise');\r\nexports.grunt = require('grunt');\r\nexports.eol = exports.grunt.util.linefeed;\r\nfunction newLineIsRedundantForTsc(newLineParameter, operatingSystem) {\r\n    if (operatingSystem === void 0) { operatingSystem = os; }\r\n    return ((newLineParameter === 'CRLF' && operatingSystem.EOL === '\\r\\n') ||\r\n        (newLineParameter === 'LF' && operatingSystem.EOL === '\\n'));\r\n}\r\nexports.newLineIsRedundantForTsc = newLineIsRedundantForTsc;\r\nfunction newLineActualAsParameter(actualNewLineChars) {\r\n    if (actualNewLineChars) {\r\n        return actualNewLineChars.replace(/\\n/g, 'LF').replace(/\\r/g, 'CR');\r\n    }\r\n    return '';\r\n}\r\nexports.newLineActualAsParameter = newLineActualAsParameter;\r\nfunction newLineParameterAsActual(parameterNewLineChars) {\r\n    if (parameterNewLineChars) {\r\n        return parameterNewLineChars.replace(/LF/g, '\\n').replace(/CR/g, '\\r');\r\n    }\r\n    return '';\r\n}\r\nexports.newLineParameterAsActual = newLineParameterAsActual;\r\n// Converts \"C:\\boo\" , \"C:\\boo\\foo.ts\" => \"./foo.ts\"; Works on unix as well.\r\nfunction makeRelativePath(folderpath, filename, forceRelative) {\r\n    if (forceRelative === void 0) { forceRelative = false; }\r\n    var relativePath = path.relative(folderpath, filename).split('\\\\').join('/');\r\n    if (forceRelative && relativePath[0] !== '.') {\r\n        relativePath = './' + relativePath;\r\n    }\r\n    return relativePath;\r\n}\r\nexports.makeRelativePath = makeRelativePath;\r\n// Finds the longest common section of a collection of strings.\r\n// Simply sorting and comparing first and last http://stackoverflow.com/a/1917041/390330\r\nfunction sharedStart(array) {\r\n    if (array.length === 0) {\r\n        throw 'Cannot find common root of empty array.';\r\n    }\r\n    var A = array.slice(0).sort(), firstWord = A[0], lastWord = A[A.length - 1];\r\n    if (firstWord === lastWord) {\r\n        return firstWord;\r\n    }\r\n    else {\r\n        var i = -1;\r\n        do {\r\n            i += 1;\r\n            var firstWordChar = firstWord.charAt(i);\r\n            var lastWordChar = lastWord.charAt(i);\r\n        } while (firstWordChar === lastWordChar);\r\n        return firstWord.substring(0, i);\r\n    }\r\n}\r\n// Finds the common system path between paths\r\n// Explanation of how is inline\r\nfunction findCommonPath(paths, pathSeperator) {\r\n    // Now for \"C:\\u\\starter\" \"C:\\u\\started\" => \"C:\\u\\starte\"\r\n    var largetStartSegement = sharedStart(paths);\r\n    // For \"C:\\u\\starte\" => C:\\u\\\r\n    var ending = largetStartSegement.lastIndexOf(pathSeperator);\r\n    return largetStartSegement.substr(0, ending);\r\n}\r\nexports.findCommonPath = findCommonPath;\r\n/**\r\n * Returns the result of an array inserted into another, starting at the given index.\r\n */\r\nfunction insertArrayAt(array, index, arrayToInsert) {\r\n    var updated = array.slice(0);\r\n    var spliceAt = [index, 0];\r\n    Array.prototype.splice.apply(updated, spliceAt.concat(arrayToInsert));\r\n    return updated;\r\n}\r\nexports.insertArrayAt = insertArrayAt;\r\n/**\r\n * Compares the end of the string with the given suffix for literal equality.\r\n *\r\n * @returns {boolean} whether the string ends with the suffix literally.\r\n */\r\nfunction endsWith(str, suffix) {\r\n    return str.indexOf(suffix, str.length - suffix.length) !== -1;\r\n}\r\nexports.endsWith = endsWith;\r\nfunction stripQuotesIfQuoted(possiblyQuotedString) {\r\n    if (!possiblyQuotedString.length || possiblyQuotedString.length < 2) {\r\n        return possiblyQuotedString;\r\n    }\r\n    if (possiblyQuotedString.charAt(0) === '\"' &&\r\n        possiblyQuotedString.charAt(possiblyQuotedString.length - 1) === '\"') {\r\n        return possiblyQuotedString.substr(1, possiblyQuotedString.length - 2);\r\n    }\r\n    return possiblyQuotedString;\r\n}\r\nexports.stripQuotesIfQuoted = stripQuotesIfQuoted;\r\nfunction isJavaScriptFile(filePath) {\r\n    if (filePath.toLowerCase) {\r\n        var normalizedFile = path.resolve(stripQuotesIfQuoted(filePath)).toLowerCase();\r\n        return endsWith(normalizedFile, '.js');\r\n    }\r\n    return false;\r\n}\r\nexports.isJavaScriptFile = isJavaScriptFile;\r\n/** function for formatting strings\r\n * ('{0} says {1}','la','ba' ) => 'la says ba'\r\n */\r\nfunction format(str) {\r\n    var args = [];\r\n    for (var _i = 1; _i < arguments.length; _i++) {\r\n        args[_i - 1] = arguments[_i];\r\n    }\r\n    return str.replace(/{(\\d+)}/g, function (m, i) {\r\n        return args[i] !== undefined ? args[i] : m;\r\n    });\r\n}\r\nexports.format = format;\r\n/**\r\n * Get a random hex value\r\n *\r\n * @returns {string} hex string\r\n */\r\nfunction getRandomHex(length) {\r\n    if (length === void 0) { length = 16; }\r\n    var name = '';\r\n    do {\r\n        name += Math.round(Math.random() * Math.pow(16, 8)).toString(16);\r\n    } while (name.length < length);\r\n    return name.substr(0, length);\r\n}\r\nexports.getRandomHex = getRandomHex;\r\n/**\r\n * Get a unique temp file\r\n *\r\n * @returns {string} unique-ish path to file in given directory.\r\n * @throws when it cannot create a temp file in the specified directory\r\n */\r\nfunction getTempFile(prefix, dir, extension) {\r\n    if (dir === void 0) { dir = ''; }\r\n    if (extension === void 0) { extension = '.tmp.txt'; }\r\n    prefix = (prefix ? prefix + '-' : '');\r\n    var attempts = 100;\r\n    do {\r\n        var name = prefix + getRandomHex(8) + extension;\r\n        var dest = path.join(dir, name);\r\n        if (!fs.existsSync(dest)) {\r\n            return dest;\r\n        }\r\n        attempts--;\r\n    } while (attempts > 0);\r\n    throw 'Cannot create temp file in ' + dir;\r\n}\r\nexports.getTempFile = getTempFile;\r\n/////////////////////////////////////////////////////////////////////////\r\n// From https://github.com/centi/node-dirutils/blob/master/index.js\r\n// Slightly modified. See BAS\r\n////////////////////////////////////////////////////////////////////////\r\n/**\r\n * Get all files from a directory and all its subdirectories.\r\n * @param {String} dirPath A path to a directory\r\n * @param {RegExp|Function} exclude Defines which files should be excluded.\r\n     Can be a RegExp (whole filepath is tested) or a Function which will get the filepath\r\n     as an argument and should return true (exclude file) or false (do not exclude).\r\n * @returns {Array} An array of files\r\n */\r\nfunction getFiles(dirPath, exclude) {\r\n    return _getAll(dirPath, exclude, true);\r\n}\r\nexports.getFiles = getFiles;\r\n;\r\n/**\r\n * Get all directories from a directory and all its subdirectories.\r\n * @param {String} dirPath A path to a directory\r\n * @param {RegExp|Function} exclude Defines which directories should be excluded.\r\n    Can be a RegExp (whole dirpath is tested) or a Function which will get the dirpath\r\n    as an argument and should return true (exclude dir) or false (do not exclude).\r\n * @returns {Array} An array of directories\r\n */\r\nfunction getDirs(dirPath, exclude) {\r\n    return _getAll(dirPath, exclude, false);\r\n}\r\nexports.getDirs = getDirs;\r\n;\r\n/**\r\n * Get all files or directories from a directory and all its subdirectories.\r\n * @param {String} dirPath A path to a directory\r\n * @param {RegExp|Function} exclude Defines which files or directories should be excluded.\r\n    Can be a RegExp (whole path is tested) or a Function which will get the path\r\n    as an argument and should return true (exclude) or false (do not exclude).\r\n * @param {Boolean} getFiles Whether to get files (true) or directories (false).\r\n * @returns {Array} An array of files or directories\r\n */\r\nfunction _getAll(dirPath, exclude, getFiles) {\r\n    var _checkDirResult = _checkDirPathArgument(dirPath);\r\n    var _checkExcludeResult;\r\n    var items = [];\r\n    if (util.isError(_checkDirResult)) {\r\n        return _checkDirResult;\r\n    }\r\n    if (exclude) {\r\n        _checkExcludeResult = _checkExcludeArgument(exclude);\r\n        if (util.isError(_checkExcludeResult)) {\r\n            return _checkExcludeResult;\r\n        }\r\n    }\r\n    fs.readdirSync(dirPath).forEach(function (_item) {\r\n        var _itempath = path.normalize(dirPath + '/' + _item);\r\n        if (exclude) {\r\n            if (util.isRegExp(exclude)) {\r\n                if (exclude.test(_itempath)) {\r\n                    return;\r\n                }\r\n            }\r\n            else {\r\n                if (exclude(_itempath)) {\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        if (fs.statSync(_itempath).isDirectory()) {\r\n            if (!getFiles) {\r\n                items.push(_itempath);\r\n            }\r\n            items = items.concat(_getAll(_itempath, exclude, getFiles));\r\n        }\r\n        else {\r\n            if (getFiles === true) {\r\n                items.push(_itempath);\r\n            }\r\n        }\r\n    });\r\n    return items;\r\n}\r\n/**\r\n * Check if the dirPath is provided and if it does exist on the filesystem.\r\n * @param {String} dirPath A path to the directory\r\n * @returns {String|Error} Returns the dirPath if everything is allright or an Error otherwise.\r\n */\r\nfunction _checkDirPathArgument(dirPath) {\r\n    if (!dirPath || dirPath === '') {\r\n        return new Error('Dir path is missing!');\r\n    }\r\n    if (!fs.existsSync(dirPath)) {\r\n        return new Error('Dir path does not exist: ' + dirPath);\r\n    }\r\n    return dirPath;\r\n}\r\n/**\r\n * Check if the exclude argument is a RegExp or a Function.\r\n * @param {RegExp|Function} exclude A RegExp or a Function which returns true/false.\r\n * @returns {String|Error} Returns the exclude argument if everything is allright or an Error otherwise.\r\n */\r\nfunction _checkExcludeArgument(exclude) {\r\n    if (!util.isRegExp(exclude) && typeof (exclude) !== 'function') {\r\n        return new Error('Argument exclude should be a RegExp or a Function');\r\n    }\r\n    return exclude;\r\n}\r\nfunction firstElementWithValue(elements, defaultResult) {\r\n    if (defaultResult === void 0) { defaultResult = null; }\r\n    var result = defaultResult;\r\n    _.each(elements, function (item) {\r\n        if (hasValue(item)) {\r\n            result = item;\r\n            return false; // break out of lodash loop\r\n        }\r\n        return undefined;\r\n    });\r\n    return result;\r\n}\r\nexports.firstElementWithValue = firstElementWithValue;\r\nfunction hasValue(thing) {\r\n    return !_.isNull(thing) && !_.isUndefined(thing);\r\n}\r\nexports.hasValue = hasValue;\r\nfunction getOrGetFirst(getFrom) {\r\n    if (_.isArray(getFrom)) {\r\n        if (getFrom.length > 0) {\r\n            return getFrom[0];\r\n        }\r\n        return '';\r\n    }\r\n    return getFrom;\r\n}\r\nexports.getOrGetFirst = getOrGetFirst;\r\nfunction enclosePathInQuotesIfRequired(path) {\r\n    if (!path || !path.indexOf) {\r\n        return path;\r\n    }\r\n    if (path.indexOf(' ') === -1) {\r\n        return path;\r\n    }\r\n    else {\r\n        var newPath = path.trim();\r\n        if (newPath.indexOf('\"') === 0 && newPath.lastIndexOf('\"') === newPath.length - 1) {\r\n            return newPath;\r\n        }\r\n        else {\r\n            return '\"' + newPath + '\"';\r\n        }\r\n    }\r\n}\r\nexports.enclosePathInQuotesIfRequired = enclosePathInQuotesIfRequired;\r\n/**\r\n * Time a function and print the result.\r\n *\r\n * @param makeIt the code to time\r\n * @returns the result of the block of code\r\n */\r\nfunction timeIt(makeIt) {\r\n    var starttime = new Date().getTime();\r\n    var it = makeIt();\r\n    var endtime = new Date().getTime();\r\n    return {\r\n        it: it,\r\n        time: endtime - starttime\r\n    };\r\n}\r\nexports.timeIt = timeIt;\r\n/**\r\n * Run a map operation async in series (simplified)\r\n */\r\nfunction asyncSeries(items, callPerItem) {\r\n    items = items.slice(0);\r\n    var memo = [];\r\n    // Run one at a time\r\n    return new es6_promise_1.Promise(function (resolve, reject) {\r\n        var next = function () {\r\n            if (items.length === 0) {\r\n                resolve(memo);\r\n                return;\r\n            }\r\n            es6_promise_1.Promise\r\n                .cast(callPerItem(items.shift()))\r\n                .then(function (result) {\r\n                memo.push(result);\r\n                next();\r\n            }, reject);\r\n        };\r\n        next();\r\n    });\r\n}\r\nexports.asyncSeries = asyncSeries;\r\nfunction copyFile(srcFile, destFile, callback, encoding) {\r\n    if (encoding === void 0) { encoding = 'utf8'; }\r\n    fs.readFile(srcFile, encoding, function (err, data) {\r\n        fs.writeFile(destFile, data, encoding, function (err) {\r\n            if (err) {\r\n                return callback(err);\r\n            }\r\n            return callback();\r\n        });\r\n    });\r\n}\r\nexports.copyFile = copyFile;\r\nfunction readAndParseJSONFromFileSync(fileName, encoding) {\r\n    if (encoding === void 0) { encoding = 'utf8'; }\r\n    var textContent, result;\r\n    try {\r\n        textContent = fs.readFileSync(fileName, encoding);\r\n    }\r\n    catch (ex) {\r\n        throw new Error(\"Error reading file \" + fileName + \": \" + ex);\r\n    }\r\n    try {\r\n        result = JSON.parse(textContent);\r\n    }\r\n    catch (ex) {\r\n        throw new Error(\"Error parsing JSON in file \" + fileName + \": \" + ex);\r\n    }\r\n    return result;\r\n}\r\nexports.readAndParseJSONFromFileSync = readAndParseJSONFromFileSync;\r\nfunction shouldCompile(options) {\r\n    return !!options.compile;\r\n}\r\nexports.shouldCompile = shouldCompile;\r\nfunction shouldPassThrough(options) {\r\n    return (options.tsconfig && options.tsconfig.passThrough);\r\n}\r\nexports.shouldPassThrough = shouldPassThrough;\r\n//# sourceMappingURL=utils.js.map","/home/travis/build/npmtest/node-npmtest-grunt-ts/node_modules/grunt-ts/tasks/modules/compile.js":"/// <reference path=\"../../defs/tsd.d.ts\"/>\r\n/// <reference path=\"./interfaces.d.ts\"/>\r\n'use strict';\r\nvar path = require('path');\r\nvar fs = require('fs');\r\nvar _ = require('lodash');\r\nvar utils = require('./utils');\r\nvar cache = require('./cacheUtils');\r\nvar semver = require('semver');\r\nvar es6_promise_1 = require('es6-promise');\r\nexports.grunt = require('grunt');\r\n///////////////////////////\r\n// Helper\r\n///////////////////////////\r\nvar executeNode;\r\nvar executeNodeDefault = function (args, optionalInfo) {\r\n    return new es6_promise_1.Promise(function (resolve, reject) {\r\n        exports.grunt.util.spawn({\r\n            cmd: process.execPath,\r\n            args: args\r\n        }, function (error, result, code) {\r\n            var ret = {\r\n                code: code,\r\n                // New TypeScript compiler uses stdout for user code errors. Old one used stderr.\r\n                output: result.stdout || result.stderr\r\n            };\r\n            resolve(ret);\r\n        });\r\n    });\r\n};\r\n/////////////////////////////////////////////////////////////////\r\n// Fast Compilation\r\n/////////////////////////////////////////////////////////////////\r\n// Map to store if the cache was cleared after the gruntfile was parsed\r\nvar cacheClearedOnce = {};\r\nfunction getChangedFiles(files, targetName) {\r\n    files = cache.getNewFilesForTarget(files, targetName);\r\n    _.forEach(files, function (file) {\r\n        exports.grunt.log.writeln(('### Fast Compile >>' + file).cyan);\r\n    });\r\n    return files;\r\n}\r\nfunction resetChangedFiles(files, targetName) {\r\n    cache.compileSuccessfull(files, targetName);\r\n}\r\nfunction clearCache(targetName) {\r\n    cache.clearCache(targetName);\r\n    cacheClearedOnce[targetName] = true;\r\n}\r\n/////////////////////////////////////////////////////////////////////\r\n// tsc handling\r\n////////////////////////////////////////////////////////////////////\r\nfunction resolveTypeScriptBinPath() {\r\n    var ownRoot = path.resolve(path.dirname((module).filename), '../..');\r\n    var userRoot = path.resolve(ownRoot, '..', '..');\r\n    var binSub = path.join('node_modules', 'typescript', 'bin');\r\n    if (fs.existsSync(path.join(userRoot, binSub))) {\r\n        // Using project override\r\n        return path.join(userRoot, binSub);\r\n    }\r\n    return path.join(ownRoot, binSub);\r\n}\r\nfunction getTsc(binPath) {\r\n    return path.join(binPath, 'tsc');\r\n}\r\nfunction compileResultMeansFastCacheShouldBeRefreshed(options, result) {\r\n    return (options.fast !== 'never' &&\r\n        (result.code === 0 || (result.code === 2 && !options.failOnTypeErrors)));\r\n}\r\nexports.compileResultMeansFastCacheShouldBeRefreshed = compileResultMeansFastCacheShouldBeRefreshed;\r\nfunction compileAllFiles(options, compilationInfo) {\r\n    var targetFiles = compilationInfo.src;\r\n    // Make a local copy so we can modify files without having external side effects\r\n    var files = _.map(targetFiles, function (file) { return file; });\r\n    var newFiles = files;\r\n    if (options.fast === 'watch') {\r\n        // if this is the first time its running after this file was loaded\r\n        if (cacheClearedOnce[exports.grunt.task.current.target] === undefined) {\r\n            // Then clear the cache for this target\r\n            clearCache(options.targetName);\r\n        }\r\n    }\r\n    if (options.fast !== 'never') {\r\n        if (compilationInfo.out) {\r\n            exports.grunt.log.writeln('Fast compile will not work when --out is specified. Ignoring fast compilation'.cyan);\r\n        }\r\n        else {\r\n            newFiles = getChangedFiles(files, options.targetName);\r\n            if (newFiles.length !== 0 || options.testExecute || utils.shouldPassThrough(options)) {\r\n                files = newFiles;\r\n                // If outDir is specified but no baseDir is specified we need to determine one\r\n                if (compilationInfo.outDir && !options.baseDir) {\r\n                    options.baseDir = utils.findCommonPath(files, '/');\r\n                }\r\n            }\r\n            else {\r\n                exports.grunt.log.writeln('No file changes were detected. Skipping Compile'.green);\r\n                return new es6_promise_1.Promise(function (resolve) {\r\n                    var ret = {\r\n                        code: 0,\r\n                        fileCount: 0,\r\n                        output: 'No files compiled as no change detected'\r\n                    };\r\n                    resolve(ret);\r\n                });\r\n            }\r\n        }\r\n    }\r\n    // Transform files as needed. Currently all of this logic in is one module\r\n    // transformers.transformFiles(newFiles, targetFiles, target, task);\r\n    // If baseDir is specified create a temp tsc file to make sure that `--outDir` works fine\r\n    // see https://github.com/grunt-ts/grunt-ts/issues/77\r\n    var baseDirFile = '.baseDir.ts';\r\n    var baseDirFilePath;\r\n    if (compilationInfo.outDir && options.baseDir && files.length > 0) {\r\n        baseDirFilePath = path.join(options.baseDir, baseDirFile);\r\n        if (!fs.existsSync(baseDirFilePath)) {\r\n            exports.grunt.file.write(baseDirFilePath, '// Ignore this file. See https://github.com/grunt-ts/grunt-ts/issues/77');\r\n        }\r\n        files.push(baseDirFilePath);\r\n    }\r\n    // If reference and out are both specified.\r\n    // Then only compile the updated reference file as that contains the correct order\r\n    if (options.reference && compilationInfo.out) {\r\n        var referenceFile = path.resolve(options.reference);\r\n        files = [referenceFile];\r\n    }\r\n    // Quote the files to compile. Needed for command line parsing by tsc\r\n    files = _.map(files, function (item) { return (\"\\\"\" + path.resolve(item) + \"\\\"\"); });\r\n    var args = files.slice(0), tsc, tscVersion = '';\r\n    var tsconfig = options.tsconfig;\r\n    if (options.compiler) {\r\n        // Custom compiler (task.compiler)\r\n        exports.grunt.log.writeln('Using the custom compiler : ' + options.compiler);\r\n        tsc = options.compiler;\r\n        tscVersion = '';\r\n    }\r\n    else {\r\n        // the bundled OR npm module based compiler\r\n        var tscPath = resolveTypeScriptBinPath();\r\n        tsc = getTsc(tscPath);\r\n        tscVersion = getTscVersion(tscPath);\r\n        exports.grunt.log.writeln('Using tsc v' + tscVersion);\r\n    }\r\n    if (tsconfig && tsconfig.passThrough) {\r\n        args.push('--project', tsconfig.tsconfig);\r\n    }\r\n    else {\r\n        if (options.sourceMap) {\r\n            args.push('--sourcemap');\r\n        }\r\n        if (options.emitDecoratorMetadata) {\r\n            args.push('--emitDecoratorMetadata');\r\n        }\r\n        if (options.declaration) {\r\n            args.push('--declaration');\r\n        }\r\n        if (options.removeComments) {\r\n            args.push('--removeComments');\r\n        }\r\n        if (options.noImplicitAny) {\r\n            args.push('--noImplicitAny');\r\n        }\r\n        if (options.noResolve) {\r\n            args.push('--noResolve');\r\n        }\r\n        if (options.noEmitOnError) {\r\n            args.push('--noEmitOnError');\r\n        }\r\n        if (options.preserveConstEnums) {\r\n            args.push('--preserveConstEnums');\r\n        }\r\n        if (options.suppressImplicitAnyIndexErrors) {\r\n            args.push('--suppressImplicitAnyIndexErrors');\r\n        }\r\n        if (options.noEmit) {\r\n            args.push('--noEmit');\r\n        }\r\n        if (options.inlineSources) {\r\n            args.push('--inlineSources');\r\n        }\r\n        if (options.inlineSourceMap) {\r\n            args.push('--inlineSourceMap');\r\n        }\r\n        if (options.newLine && !utils.newLineIsRedundantForTsc(options.newLine)) {\r\n            args.push('--newLine', options.newLine);\r\n        }\r\n        if (options.isolatedModules) {\r\n            args.push('--isolatedModules');\r\n        }\r\n        if (options.noEmitHelpers) {\r\n            args.push('--noEmitHelpers');\r\n        }\r\n        if (options.experimentalDecorators) {\r\n            args.push('--experimentalDecorators');\r\n        }\r\n        if (options.experimentalAsyncFunctions) {\r\n            args.push('--experimentalAsyncFunctions');\r\n        }\r\n        if (options.jsx) {\r\n            args.push('--jsx', options.jsx.toLocaleLowerCase());\r\n        }\r\n        if (options.moduleResolution) {\r\n            args.push('--moduleResolution', options.moduleResolution.toLocaleLowerCase());\r\n        }\r\n        if (options.rootDir) {\r\n            args.push('--rootDir', options.rootDir);\r\n        }\r\n        if (options.noLib) {\r\n            args.push('--noLib');\r\n        }\r\n        if (options.emitBOM) {\r\n            args.push('--emitBOM');\r\n        }\r\n        if (options.locale) {\r\n            args.push('--locale', options.locale);\r\n        }\r\n        if (options.suppressExcessPropertyErrors) {\r\n            args.push('--suppressExcessPropertyErrors');\r\n        }\r\n        if (options.stripInternal) {\r\n            args.push('--stripInternal');\r\n        }\r\n        if (options.allowSyntheticDefaultImports) {\r\n            args.push('--allowSyntheticDefaultImports');\r\n        }\r\n        if (options.reactNamespace) {\r\n            args.push('--reactNamespace', options.reactNamespace);\r\n        }\r\n        if (options.skipDefaultLibCheck) {\r\n            args.push('--skipDefaultLibCheck');\r\n        }\r\n        if (options.pretty) {\r\n            args.push('--pretty');\r\n        }\r\n        if (options.allowUnusedLabels) {\r\n            args.push('--allowUnusedLabels');\r\n        }\r\n        if (options.noImplicitReturns) {\r\n            args.push('--noImplicitReturns');\r\n        }\r\n        if (options.noFallthroughCasesInSwitch) {\r\n            args.push('--noFallthroughCasesInSwitch');\r\n        }\r\n        if (options.allowUnreachableCode) {\r\n            args.push('--allowUnreachableCode');\r\n        }\r\n        if (options.forceConsistentCasingInFileNames) {\r\n            args.push('--forceConsistentCasingInFileNames');\r\n        }\r\n        if (options.allowJs) {\r\n            args.push('--allowJs');\r\n        }\r\n        if (options.noImplicitUseStrict) {\r\n            args.push('--noImplicitUseStrict');\r\n        }\r\n        args.push('--target', options.target.toUpperCase());\r\n        if (options.module) {\r\n            var moduleOptionString = ('' + options.module).toLowerCase();\r\n            if ('amd|commonjs|system|umd|es6|es2015'.indexOf(moduleOptionString) > -1) {\r\n                args.push('--module', moduleOptionString);\r\n            }\r\n            else {\r\n                console.warn('WARNING: Option \"module\" only supports \"amd\" | \"commonjs\" | \"system\" | \"umd\" | \"es6\" | \"es2015\" '.magenta);\r\n            }\r\n        }\r\n        if (compilationInfo.outDir) {\r\n            if (compilationInfo.out) {\r\n                console.warn('WARNING: Option \"out\" and \"outDir\" should not be used together'.magenta);\r\n            }\r\n            args.push('--outDir', compilationInfo.outDir);\r\n        }\r\n        if (compilationInfo.out) {\r\n            // We only pass --out instead of --outFile for backward-compatability reasons.\r\n            // It is the same for purposes of the command-line (the subtle difference is handled in the tsconfig code\r\n            //  and the value of --outFile is copied to --out).\r\n            args.push('--out', compilationInfo.out);\r\n        }\r\n        if (compilationInfo.dest && (!compilationInfo.out) && (!compilationInfo.outDir)) {\r\n            if (utils.isJavaScriptFile(compilationInfo.dest)) {\r\n                args.push('--out', compilationInfo.dest);\r\n            }\r\n            else {\r\n                if (compilationInfo.dest === 'src') {\r\n                    console.warn(('WARNING: Destination for target \"' + options.targetName + '\" is \"src\", which is the default.  If you have' +\r\n                        ' forgotten to specify a \"dest\" parameter, please add it.  If this is correct, you may wish' +\r\n                        ' to change the \"dest\" parameter to \"src/\" or just ignore this warning.').magenta);\r\n                }\r\n                if (Array.isArray(compilationInfo.dest)) {\r\n                    if (compilationInfo.dest.length === 0) {\r\n                    }\r\n                    else if (compilationInfo.dest.length > 0) {\r\n                        console.warn((('WARNING: \"dest\" for target \"' + options.targetName + '\" is an array.  This is not supported by the' +\r\n                            ' TypeScript compiler or grunt-ts.' +\r\n                            ((compilationInfo.dest.length > 1) ? '  Only the first \"dest\" will be used.  The' +\r\n                                ' remaining items will be truncated.' : ''))).magenta);\r\n                        args.push('--outDir', compilationInfo.dest[0]);\r\n                    }\r\n                }\r\n                else {\r\n                    args.push('--outDir', compilationInfo.dest);\r\n                }\r\n            }\r\n        }\r\n        if (args.indexOf('--out') > -1 && args.indexOf('--module') > -1) {\r\n            if (semver.satisfies(tscVersion, '>=1.8.0')) {\r\n                if ((options.module === 'system' || options.module === 'amd')) {\r\n                }\r\n                else {\r\n                    console.warn(('WARNING: TypeScript 1.8+ requires \"module\" to be set to' +\r\n                        'system or amd for concatenation of external modules to work.').magenta);\r\n                }\r\n            }\r\n            else {\r\n                console.warn(('WARNING: TypeScript < 1.8 does not allow external modules to be concatenated with' +\r\n                    ' --out. Any exported code may be truncated.  See TypeScript issue #1544 for' +\r\n                    ' more details.').magenta);\r\n            }\r\n        }\r\n        if (options.sourceRoot) {\r\n            args.push('--sourceRoot', options.sourceRoot);\r\n        }\r\n        if (options.mapRoot) {\r\n            args.push('--mapRoot', options.mapRoot);\r\n        }\r\n    }\r\n    if (options.additionalFlags) {\r\n        args.push(options.additionalFlags);\r\n    }\r\n    function getTscVersion(tscPath) {\r\n        var pkg = JSON.parse(fs.readFileSync(path.resolve(tscPath, '..', 'package.json')).toString());\r\n        return '' + pkg.version;\r\n    }\r\n    // To debug the tsc command\r\n    if (options.verbose) {\r\n        console.log(args.join(' ').yellow);\r\n    }\r\n    else {\r\n        exports.grunt.log.verbose.writeln(args.join(' ').yellow);\r\n    }\r\n    // Create a temp last command file and use that to guide tsc.\r\n    // Reason: passing all the files on the command line causes TSC to go in an infinite loop.\r\n    var tempfilename = utils.getTempFile('tscommand');\r\n    if (!tempfilename) {\r\n        throw (new Error('cannot create temp file'));\r\n    }\r\n    fs.writeFileSync(tempfilename, args.join(' '));\r\n    var command;\r\n    // Switch implementation if a test version of executeNode exists.\r\n    if ('testExecute' in options) {\r\n        if (_.isFunction(options.testExecute)) {\r\n            command = [tsc, args.join(' ')];\r\n            executeNode = options.testExecute;\r\n        }\r\n        else {\r\n            var invalidTestExecuteError = 'Invalid testExecute node present on target \"' +\r\n                options.targetName + '\".  Value of testExecute must be a function.';\r\n            throw (new Error(invalidTestExecuteError));\r\n        }\r\n    }\r\n    else {\r\n        // this is the normal path.\r\n        command = [tsc, '@' + tempfilename];\r\n        executeNode = executeNodeDefault;\r\n    }\r\n    // Execute command\r\n    return executeNode(command, options).then(function (result) {\r\n        if (compileResultMeansFastCacheShouldBeRefreshed(options, result)) {\r\n            resetChangedFiles(newFiles, options.targetName);\r\n        }\r\n        result.fileCount = files.length;\r\n        fs.unlinkSync(tempfilename);\r\n        exports.grunt.log.writeln(result.output);\r\n        return es6_promise_1.Promise.cast(result);\r\n    }, function (err) {\r\n        fs.unlinkSync(tempfilename);\r\n        throw err;\r\n    });\r\n}\r\nexports.compileAllFiles = compileAllFiles;\r\n//# sourceMappingURL=compile.js.map","/home/travis/build/npmtest/node-npmtest-grunt-ts/node_modules/grunt-ts/tasks/modules/cacheUtils.js":"/// <reference path=\"../../defs/tsd.d.ts\"/>\r\n\"use strict\";\r\n// Source based on : https://github.com/tschaub/grunt-newer/blob/master/lib/util.js\r\nvar fs = require('fs');\r\nvar _ = require('lodash');\r\nvar path = require('path');\r\nvar crypto = require('crypto');\r\nvar grunt = require('grunt');\r\nvar rimraf = require('rimraf');\r\n//////////////////////\r\n//  Basic algo: \r\n//        - We have a timestamp file per target. \r\n//        - We use the mtime of this file to filter out\r\n//              new files for this target\r\n//        - Finally we can update the timestamp file with new time\r\n/////////////////////\r\nexports.cacheDir = '.tscache';\r\n//////////////////////////////\r\n// File stamp based filtering\r\n//////////////////////////////\r\nfunction getStampPath(targetName) {\r\n    return path.join(exports.cacheDir, targetName, 'timestamp');\r\n}\r\nfunction getLastSuccessfullCompile(targetName) {\r\n    var stampFile = getStampPath(targetName);\r\n    try {\r\n        return fs.statSync(stampFile).mtime;\r\n    }\r\n    catch (err) {\r\n        // task has never succeeded before\r\n        return new Date(0);\r\n    }\r\n}\r\nfunction getFilesNewerThan(paths, time) {\r\n    var filtered = _.filter(paths, function (path) {\r\n        var stats = fs.statSync(path);\r\n        return stats.mtime > time;\r\n    });\r\n    return filtered;\r\n}\r\nfunction anyNewerThan(paths, time) {\r\n    return getFilesNewerThan(paths, time).length > 0;\r\n}\r\nexports.anyNewerThan = anyNewerThan;\r\nfunction filterPathsByTime(paths, targetName) {\r\n    var time = getLastSuccessfullCompile(targetName);\r\n    return getFilesNewerThan(paths, time);\r\n}\r\nexports.filterPathsByTime = filterPathsByTime;\r\n//////////////////////////////\r\n// File hash based filtering\r\n//////////////////////////////\r\n/**\r\n * Get path to cached file hash for a target.\r\n * @return {string} Path to hash.\r\n */\r\nfunction getHashPath(filePath, targetName) {\r\n    var hashedName = path.basename(filePath) + '-' + crypto.createHash('md5').update(filePath).digest('hex');\r\n    return path.join(exports.cacheDir, targetName, 'hashes', hashedName);\r\n}\r\n/**\r\n * Get an existing hash for a file (if it exists).\r\n */\r\nfunction getExistingHash(filePath, targetName) {\r\n    var hashPath = getHashPath(filePath, targetName);\r\n    var exists = fs.existsSync(hashPath);\r\n    if (!exists) {\r\n        return null;\r\n    }\r\n    return fs.readFileSync(hashPath).toString();\r\n}\r\n/**\r\n * Generate a hash (md5sum) of a file contents.\r\n * @param {string} filePath Path to file.\r\n */\r\nfunction generateFileHash(filePath) {\r\n    var md5sum = crypto.createHash('md5');\r\n    var data = fs.readFileSync(filePath);\r\n    md5sum.update(data);\r\n    return md5sum.digest('hex');\r\n}\r\n/**\r\n * Filter files based on hashed contents.\r\n * @param {Array.<string>} paths List of paths to files.\r\n * @param {string} cacheDir Cache directory.\r\n * @param {string} taskName Task name.\r\n * @param {string} targetName Target name.\r\n * @param {function(Error, Array.<string>)} callback Callback called with any\r\n *     error and a filtered list of files that only includes files with hashes\r\n *     that are different than the cached hashes for the same files.\r\n */\r\nfunction filterPathsByHash(filePaths, targetName) {\r\n    var filtered = _.filter(filePaths, function (filePath) {\r\n        var previous = getExistingHash(filePath, targetName);\r\n        var current = generateFileHash(filePath);\r\n        return previous !== current;\r\n    });\r\n    return filtered;\r\n}\r\nfunction updateHashes(filePaths, targetName) {\r\n    _.forEach(filePaths, function (filePath) {\r\n        var hashPath = getHashPath(filePath, targetName);\r\n        var hash = generateFileHash(filePath);\r\n        grunt.file.write(hashPath, hash);\r\n    });\r\n}\r\n//////////////////////////////\r\n// External functions\r\n//////////////////////////////\r\n/**\r\n * Filter a list of files by target\r\n */\r\nfunction getNewFilesForTarget(paths, targetName) {\r\n    var step1 = filterPathsByTime(paths, targetName);\r\n    var step2 = filterPathsByHash(step1, targetName);\r\n    return step2;\r\n}\r\nexports.getNewFilesForTarget = getNewFilesForTarget;\r\n/**\r\n * Update the timestamp for a target to denote last successful compile\r\n */\r\nfunction compileSuccessfull(paths, targetName) {\r\n    // update timestamp\r\n    grunt.file.write(getStampPath(targetName), '');\r\n    // update filehash\r\n    updateHashes(paths, targetName);\r\n}\r\nexports.compileSuccessfull = compileSuccessfull;\r\nfunction clearCache(targetName) {\r\n    var cacheDirForTarget = path.join(exports.cacheDir, targetName);\r\n    try {\r\n        if (fs.existsSync(cacheDirForTarget)) {\r\n            rimraf.sync(cacheDirForTarget);\r\n            grunt.log.writeln(('Cleared fast compile cache for target: ' + targetName).cyan);\r\n        }\r\n    }\r\n    catch (ex) {\r\n        grunt.log.writeln(('Failed to clear compile cache for target: ' + targetName).red);\r\n    }\r\n}\r\nexports.clearCache = clearCache;\r\n//# sourceMappingURL=cacheUtils.js.map","/home/travis/build/npmtest/node-npmtest-grunt-ts/node_modules/grunt-ts/tasks/modules/reference.js":"/// <reference path=\"../../defs/tsd.d.ts\"/>\r\n\"use strict\";\r\nvar _ = require('lodash');\r\nvar _str = require('underscore.string');\r\nvar fs = require('fs');\r\nvar grunt = require('grunt');\r\nvar utils = require('./utils');\r\n/////////////////////////////////////////////////////////////////////\r\n// Reference file logic\r\n////////////////////////////////////////////////////////////////////\r\n// Updates the reference file\r\nfunction updateReferenceFile(files, generatedFiles, referenceFile, referencePath, eol) {\r\n    var referenceIntro = '/// <reference path=\"';\r\n    var referenceEnd = '\" />';\r\n    var referenceMatch = /\\/\\/\\/ <reference path=\\\"(.*?)\\\"/;\r\n    var ourSignatureStart = '//grunt-start';\r\n    var ourSignatureEnd = '//grunt-end';\r\n    // remove the generated files from files:\r\n    files = _.difference(files, generatedFiles);\r\n    var lines = []; // All lines of the file\r\n    var origFileLines = []; // The lines we do not modify and send out as is. Lines will we reach grunt-ts generated\r\n    var origFileReferences = []; // The list of files already there that we do not need to manage\r\n    // Location of our generated references\r\n    // By default at start of file\r\n    var signatureSectionPosition = 0;\r\n    var i;\r\n    // Read the original file if it exists\r\n    var referenceContents = '';\r\n    if (fs.existsSync(referenceFile)) {\r\n        referenceContents = fs.readFileSync(referenceFile).toString();\r\n        lines = referenceContents.split(/\\r\\n|\\r|\\n/);\r\n        var inSignatureSection = false;\r\n        // By default our signature goes at end of file\r\n        signatureSectionPosition = lines.length;\r\n        for (i = 0; i < lines.length; i++) {\r\n            var line = _str.trim(lines[i]);\r\n            // Skip logic for our generated section\r\n            if (_str.include(line, ourSignatureStart)) {\r\n                // Wait for the end signature:\r\n                signatureSectionPosition = i;\r\n                inSignatureSection = true;\r\n                continue;\r\n            }\r\n            if (_str.include(line, ourSignatureEnd)) {\r\n                inSignatureSection = false;\r\n                continue;\r\n            }\r\n            if (inSignatureSection) {\r\n                continue;\r\n            }\r\n            // store the line\r\n            origFileLines.push(line);\r\n            // Fetch the existing reference's filename if any:\r\n            if (_str.include(line, referenceIntro)) {\r\n                var match = line.match(referenceMatch);\r\n                var filename = match[1];\r\n                origFileReferences.push(filename);\r\n            }\r\n        }\r\n    }\r\n    // Put in the generated files\r\n    generatedFiles = _.map(generatedFiles, function (file) { return referenceIntro + utils.makeRelativePath(referencePath, file) + referenceEnd; });\r\n    var contents = utils.insertArrayAt([ourSignatureStart], 1, generatedFiles);\r\n    // Put in the new / observed missing files:\r\n    files.forEach(function (filename) {\r\n        // The file we are about to add\r\n        var filepath = utils.makeRelativePath(referencePath, filename);\r\n        // If there are orig references\r\n        if (origFileReferences.length) {\r\n            if (_.contains(origFileReferences, filepath)) {\r\n                return;\r\n            }\r\n        }\r\n        // Finally add the filepath\r\n        contents.push(referenceIntro + filepath + referenceEnd);\r\n    });\r\n    contents.push(ourSignatureEnd);\r\n    var updatedFileLines = utils.insertArrayAt(origFileLines, signatureSectionPosition, contents);\r\n    var updatedFileContents = updatedFileLines.join(eol);\r\n    // Modify the orig contents to put in our contents only if changed\r\n    // Also Return whether the file was changed\r\n    if (updatedFileContents !== referenceContents) {\r\n        grunt.file.write(referenceFile, updatedFileContents);\r\n        return true;\r\n    }\r\n    else {\r\n        return false;\r\n    }\r\n}\r\nexports.updateReferenceFile = updateReferenceFile;\r\n//# sourceMappingURL=reference.js.map","/home/travis/build/npmtest/node-npmtest-grunt-ts/node_modules/grunt-ts/tasks/modules/amdLoader.js":"/// <reference path=\"../../defs/tsd.d.ts\"/>\r\n\"use strict\";\r\nvar _ = require('lodash');\r\nvar _str = require('underscore.string');\r\nvar path = require('path');\r\nvar fs = require('fs');\r\nvar utils = require('./utils');\r\nvar grunt = utils.grunt;\r\nvar pathSeperator = path.sep;\r\nfunction getReferencesInOrder(referenceFile, referencePath, generatedFiles) {\r\n    var toreturn = {\r\n        all: [],\r\n        before: [],\r\n        generated: [],\r\n        unordered: [],\r\n        after: []\r\n    };\r\n    var sortedGeneratedFiles = _.sortBy(generatedFiles);\r\n    function isGeneratedFile(filename) {\r\n        return _.indexOf(sortedGeneratedFiles, filename, true) !== -1;\r\n    }\r\n    // When reading\r\n    var referenceMatch = /\\/\\/\\/ <reference path=\\\"(.*?)\\\"/;\r\n    // When writing\r\n    var referenceIntro = '/// <reference path=\"';\r\n    // var referenceEnd = '\" />';\r\n    // The section of unordered files\r\n    var ourSignatureStart = '//grunt-start';\r\n    var ourSignatureEnd = '//grunt-end';\r\n    var lines = fs.readFileSync(referenceFile).toString().split('\\n');\r\n    // Which of the three sections we are in\r\n    var loopState = 0 /* before */;\r\n    for (var i = 0; i < lines.length; i++) {\r\n        var line = _str.trim(lines[i]);\r\n        if (_str.include(line, ourSignatureStart)) {\r\n            // Wait for the end signature:\r\n            loopState = 1 /* unordered */;\r\n        }\r\n        if (_str.include(line, ourSignatureEnd)) {\r\n            loopState = 2 /* after */;\r\n        }\r\n        // Fetch the existing reference's filename if any:\r\n        if (_str.include(line, referenceIntro)) {\r\n            var match = line.match(referenceMatch);\r\n            var filename = match[1];\r\n            switch (loopState) {\r\n                case 0 /* before */:\r\n                    toreturn.before.push(filename);\r\n                    break;\r\n                case 1 /* unordered */:\r\n                    if (isGeneratedFile(filename)) {\r\n                        toreturn.generated.push(filename);\r\n                    }\r\n                    else {\r\n                        toreturn.unordered.push(filename);\r\n                    }\r\n                    break;\r\n                case 2 /* after */:\r\n                    toreturn.after.push(filename);\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n    // Fix the references to be absolute:\r\n    toreturn.before = _.map(toreturn.before, function (relativePath) { return path.resolve(referencePath, relativePath); });\r\n    toreturn.generated = _.map(toreturn.generated, function (relativePath) { return path.resolve(referencePath, relativePath); });\r\n    toreturn.unordered = _.map(toreturn.unordered, function (relativePath) { return path.resolve(referencePath, relativePath); });\r\n    toreturn.after = _.map(toreturn.after, function (relativePath) { return path.resolve(referencePath, relativePath); });\r\n    toreturn.all = Array.prototype.concat.call([], toreturn.before, toreturn.generated, toreturn.unordered, toreturn.after);\r\n    return toreturn;\r\n}\r\nexports.getReferencesInOrder = getReferencesInOrder;\r\n// It updates based on the order of reference files\r\nfunction updateAmdLoader(referenceFile, files, loaderFile, loaderPath, outDir, newLine) {\r\n    if (newLine === void 0) { newLine = utils.eol; }\r\n    var commonPath;\r\n    var makeRelativeToOutDir = function (files) {\r\n        files = _.map(files, function (file) {\r\n            // Remove common path and replace with absolute outDir\r\n            file = file.replace(commonPath, outDir);\r\n            // remove extension '.ts' / '.tsx':\r\n            file = file.substr(0, file.lastIndexOf('.'));\r\n            // Make relative to amd loader\r\n            file = utils.makeRelativePath(loaderPath, file);\r\n            // Prepend \"./\" to prevent \"basePath\" requirejs setting from interferring:\r\n            file = './' + file;\r\n            return file;\r\n        });\r\n        return files;\r\n    };\r\n    // Read the original file if it exists\r\n    if (fs.existsSync(referenceFile)) {\r\n        grunt.log.verbose.writeln('Generating amdloader from reference file ' + referenceFile);\r\n        // Filter.d.ts,\r\n        if (files.all.length > 0) {\r\n            grunt.log.verbose.writeln('Files: ' + files.all.map(function (f) { return f.cyan; }).join(', '));\r\n        }\r\n        else {\r\n            grunt.warn('No files in reference file: ' + referenceFile);\r\n        }\r\n        if (files.before.length > 0) {\r\n            files.before = _.filter(files.before, function (file) { return !utils.endsWith(file, '.d.ts'); });\r\n            grunt.log.verbose.writeln('Before: ' + files.before.map(function (f) { return f.cyan; }).join(', '));\r\n        }\r\n        if (files.generated.length > 0) {\r\n            files.generated = _.filter(files.generated, function (file) { return !utils.endsWith(file, '.d.ts'); });\r\n            grunt.log.verbose.writeln('Generated: ' + files.generated.map(function (f) { return f.cyan; }).join(', '));\r\n        }\r\n        if (files.unordered.length > 0) {\r\n            files.unordered = _.filter(files.unordered, function (file) { return !utils.endsWith(file, '.d.ts'); });\r\n            grunt.log.verbose.writeln('Unordered: ' + files.unordered.map(function (f) { return f.cyan; }).join(', '));\r\n        }\r\n        if (files.after.length > 0) {\r\n            files.after = _.filter(files.after, function (file) { return !utils.endsWith(file, '.d.ts'); });\r\n            grunt.log.verbose.writeln('After: ' + files.after.map(function (f) { return f.cyan; }).join(', '));\r\n        }\r\n        // If target has outDir we need to make adjust the path\r\n        // c:/somefolder/ts/a , c:/somefolder/ts/inside/b  + c:/somefolder/build/js => c:/somefolder/build/js/a , c:/somefolder/build/js/inside/b\r\n        // Logic:\r\n        //     find the common structure in the source files ,and remove it\r\n        //          Finally: outDir path + remainder section\r\n        if (outDir) {\r\n            // Find common path\r\n            commonPath = utils.findCommonPath(files.before.concat(files.generated.concat(files.unordered.concat(files.after))), pathSeperator);\r\n            grunt.log.verbose.writeln('Found common path: ' + commonPath);\r\n            // Make sure outDir is absolute:\r\n            outDir = path.resolve(outDir);\r\n            grunt.log.verbose.writeln('Using outDir: ' + outDir);\r\n            grunt.log.verbose.writeln('Making files relative to outDir...');\r\n            files.before = makeRelativeToOutDir(files.before);\r\n            files.generated = makeRelativeToOutDir(files.generated);\r\n            files.unordered = makeRelativeToOutDir(files.unordered);\r\n            files.after = makeRelativeToOutDir(files.after);\r\n            var mainTemplate = _.template('define(function (require) { '\r\n                + newLine + '<%= body %>'\r\n                + newLine + '});');\r\n            // The order in the before and after files is important\r\n            var singleRequireTemplate = _.template('\\t require([<%= filename %>],function (){'\r\n                + newLine + '<%= subitem %>'\r\n                + newLine + '\\t });');\r\n            // initial sub item\r\n            var subitem = '';\r\n            // Write out a binary file:\r\n            var binaryTemplate = _.template('define([\"<%= filenames %>\"],function () {});');\r\n            var binaryFilesNames = files.before.concat(files.generated.concat(files.unordered.concat(files.after)));\r\n            var binaryContent = binaryTemplate({ filenames: binaryFilesNames.join('\",\"') });\r\n            var binFileExtension = '.bin.js';\r\n            var loaderFileWithoutExtension = path.dirname(loaderFile) + pathSeperator + path.basename(loaderFile, '.js');\r\n            var binFilename = loaderFileWithoutExtension + binFileExtension;\r\n            grunt.file.write(binFilename, binaryContent);\r\n            grunt.log.verbose.writeln('Binary AMD loader written ' + binFilename.cyan);\r\n            //\r\n            // Notice that we build inside out in the below sections:\r\n            //\r\n            // Generate fileTemplate from inside out\r\n            // Start with after\r\n            // Build the subitem for ordered after items\r\n            files.after = files.after.reverse(); // Important to build inside out\r\n            _.forEach(files.after, function (file) {\r\n                subitem = singleRequireTemplate({ filename: '\"' + file + '\"', subitem: subitem });\r\n            });\r\n            // Next up add the unordered items:\r\n            // For these we will use just one require call\r\n            if (files.unordered.length > 0) {\r\n                var unorderFileNames = files.unordered.join('\",' + newLine + '\\t\\t  \"');\r\n                subitem = singleRequireTemplate({ filename: '\"' + unorderFileNames + '\"', subitem: subitem });\r\n            }\r\n            // Next the generated files\r\n            // For these we will use just one require call\r\n            var generatedFileNames = files.generated.join('\",' + newLine + '\\t\\t  \"');\r\n            subitem = singleRequireTemplate({ filename: '\"' + generatedFileNames + '\"', subitem: subitem });\r\n            // Build the subitem for ordered before items\r\n            files.before = files.before.reverse();\r\n            _.forEach(files.before, function (file) {\r\n                subitem = singleRequireTemplate({ filename: '\"' + file + '\"', subitem: subitem });\r\n            });\r\n            // The last subitem is now the body\r\n            var output = mainTemplate({ body: subitem });\r\n            // Finally write it out\r\n            grunt.file.write(loaderFile, output);\r\n            grunt.log.verbose.writeln('AMD loader written ' + loaderFile.cyan);\r\n        }\r\n    }\r\n    else {\r\n        grunt.log.writeln('Cannot generate amd loader unless a reference file is present'.red);\r\n    }\r\n}\r\nexports.updateAmdLoader = updateAmdLoader;\r\n//# sourceMappingURL=amdLoader.js.map","/home/travis/build/npmtest/node-npmtest-grunt-ts/node_modules/grunt-ts/tasks/modules/html2ts.js":"/// <reference path=\"../../defs/tsd.d.ts\"/>\r\n\"use strict\";\r\nvar _ = require('lodash');\r\nvar fs = require('fs');\r\nvar path = require('path');\r\nvar utils = require('./utils');\r\nvar grunt = utils.grunt;\r\n/////////////////////////////////////////////////////////////////////\r\n// HTML -> TS\r\n////////////////////////////////////////////////////////////////////\r\n// html -> js processing functions:\r\n// Originally from karma-html2js-preprocessor\r\n// Refactored nicely in html2js grunt task\r\n// https://github.com/karlgoldstein/grunt-html2js/blob/master/tasks/html2js.js\r\n// Modified nlReplace to be an empty string\r\nvar escapeContent = function (content, quoteChar) {\r\n    if (quoteChar === void 0) { quoteChar = '\\''; }\r\n    var quoteRegexp = new RegExp('\\\\' + quoteChar, 'g');\r\n    var nlReplace = '';\r\n    return content.replace(quoteRegexp, '\\\\' + quoteChar).replace(/\\r?\\n/g, nlReplace);\r\n};\r\n// Convert a string to camelCase\r\n// Inspired by http://jamesroberts.name/blog/2010/02/22/string-functions-for-javascript-trim-to-camel-case-to-dashed-and-to-underscore/\r\n// Solves the issue of serving a module name that includes dashes\r\nvar toCamel = function (str) {\r\n    return str.replace(/(\\-[a-z])/g, function ($1) { return $1.toUpperCase().replace('-', ''); });\r\n};\r\n// Remove bom when reading utf8 files\r\nfunction stripBOM(str) {\r\n    return 0xFEFF === str.charCodeAt(0)\r\n        ? str.substring(1)\r\n        : str;\r\n}\r\nfunction htmlInternalTemplate(lineEnding) {\r\n    return '/* tslint:disable:max-line-length */' + lineEnding +\r\n        'module <%= modulename %> {' + lineEnding +\r\n        '  export var <%= varname %> = \\'<%= content %>\\';' + lineEnding +\r\n        '}' + lineEnding;\r\n}\r\n;\r\n// Compile an HTML file to a TS file\r\n// Return the filename. This filename will be required by reference.ts\r\nfunction compileHTML(filename, options) {\r\n    grunt.log.verbose.writeln('Compiling HTML: ' + filename);\r\n    var htmlContent = escapeContent(fs.readFileSync(filename).toString());\r\n    htmlContent = stripBOM(htmlContent);\r\n    // TODO: place a minification pipeline here if you want.\r\n    var ext = path.extname(filename).replace('.', '');\r\n    var extFreename = path.basename(filename, '.' + ext);\r\n    var moduleName = toCamel(options.moduleFunction({ ext: ext, filename: extFreename }));\r\n    var varName = toCamel(options.varFunction({ ext: ext, filename: extFreename }).replace(/\\./g, '_'));\r\n    var fileContent;\r\n    if (!options.htmlOutputTemplate) {\r\n        fileContent = _.template(htmlInternalTemplate(options.eol))({ modulename: moduleName, varname: varName, content: htmlContent });\r\n    }\r\n    else {\r\n        fileContent = _.template(replaceNewLines(options.htmlOutputTemplate, options.eol))({ modulename: moduleName, varname: varName, content: htmlContent });\r\n    }\r\n    // Write the content to a file\r\n    var outputfile = getOutputFile(filename, options.htmlOutDir, options.flatten);\r\n    mkdirParent(path.dirname(outputfile));\r\n    fs.writeFileSync(outputfile, fileContent);\r\n    return outputfile;\r\n}\r\nexports.compileHTML = compileHTML;\r\n// Replace user-supplied templates newlines with newlines appropriate for the current OS\r\nfunction replaceNewLines(input, newLines) {\r\n    return input.replace(/\\r/g, '').replace(/\\n/g, newLines);\r\n}\r\nfunction getOutputFile(filename, htmlOutDir, flatten) {\r\n    var outputfile = filename;\r\n    // NOTE If an htmlOutDir was specified\r\n    if (htmlOutDir !== null) {\r\n        var dir = getPath(htmlOutDir);\r\n        if (fs.existsSync(dir)) {\r\n            var relativeFilename = filename;\r\n            if (flatten) {\r\n                relativeFilename = path.basename(filename);\r\n            }\r\n            outputfile = path.join(dir, relativeFilename);\r\n        }\r\n    }\r\n    return outputfile + '.ts';\r\n}\r\nfunction getPath(dir) {\r\n    // NOTE If we don't have a valid absolute path\r\n    if (!fs.existsSync(dir)) {\r\n        // NOTE Try relative from the current working directory\r\n        dir = path.join(process.cwd(), dir);\r\n    }\r\n    return dir;\r\n}\r\nfunction mkdirParent(dirPath, mode) {\r\n    // NOTE Call the standard fs.mkdirSync\r\n    try {\r\n        fs.mkdirSync(dirPath, mode);\r\n    }\r\n    catch (error) {\r\n        // NOTE When it fail in this way, do the custom steps\r\n        if (error && error.errno === 34) {\r\n            // NOTE Create all the parents recursively\r\n            mkdirParent(path.dirname(dirPath), mode);\r\n            // NOTE And then the directory\r\n            mkdirParent(dirPath, mode);\r\n        }\r\n    }\r\n}\r\n//# sourceMappingURL=html2ts.js.map","/home/travis/build/npmtest/node-npmtest-grunt-ts/node_modules/grunt-ts/tasks/modules/templateCache.js":"/// <reference path=\"../../defs/tsd.d.ts\"/>\r\n\"use strict\";\r\nvar _ = require('lodash');\r\nvar fs = require('fs');\r\nvar path = require('path');\r\nvar utils = require('./utils');\r\n/////////////////////////////////////////////////////////////////////\r\n// AngularJS templateCache\r\n////////////////////////////////////////////////////////////////////\r\n// templateCache processing function\r\nfunction generateTemplateCache(src, dest, basePath, eol) {\r\n    if (!src.length) {\r\n        return;\r\n    }\r\n    // Resolve the relative path from basePath to each src file\r\n    var relativePaths = _.map(src, function (anHtmlFile) { return 'text!' + utils.makeRelativePath(basePath, anHtmlFile); });\r\n    var fileNames = _.map(src, function (anHtmlFile) { return path.basename(anHtmlFile); });\r\n    var fileVarialbeName = function (anHtmlFile) { return anHtmlFile.split('.').join('_').split('-').join('_'); };\r\n    var fileVariableNames = _.map(fileNames, fileVarialbeName);\r\n    var templateCacheTemplate = _.template('// You must have requirejs + text plugin loaded for this to work.'\r\n        + eol + 'define([<%=relativePathSection%>],function(<%=fileNameVariableSection%>){'\r\n        + eol + 'angular.module(\"ng\").run([\"$templateCache\",function($templateCache) {'\r\n        + eol + '<%=templateCachePut%>'\r\n        + eol + '}]);'\r\n        + eol + '});');\r\n    var relativePathSection = '\"' + relativePaths.join('\",' + eol + '\"') + '\"';\r\n    var fileNameVariableSection = fileVariableNames.join(',' + eol);\r\n    var templateCachePutTemplate = _.template('$templateCache.put(\"<%= fileName %>\", <%=fileVariableName%>);');\r\n    var templateCachePut = _.map(fileNames, function (fileName) { return templateCachePutTemplate({\r\n        fileName: fileName,\r\n        fileVariableName: fileVarialbeName(fileName)\r\n    }); }).join(eol);\r\n    var fileContent = templateCacheTemplate({\r\n        relativePathSection: relativePathSection,\r\n        fileNameVariableSection: fileNameVariableSection,\r\n        templateCachePut: templateCachePut\r\n    });\r\n    // Early exit if new templateCache doesn't change\r\n    if (fs.existsSync(dest)) {\r\n        var originalContents = fs.readFileSync(dest).toString();\r\n        if (originalContents === fileContent) {\r\n            return;\r\n        }\r\n    }\r\n    // write updated contents\r\n    fs.writeFileSync(dest, fileContent);\r\n}\r\nexports.generateTemplateCache = generateTemplateCache;\r\n//# sourceMappingURL=templateCache.js.map","/home/travis/build/npmtest/node-npmtest-grunt-ts/node_modules/grunt-ts/tasks/modules/transformers.js":"/// <reference path=\"../../defs/tsd.d.ts\"/>\r\n/// <reference path=\"./interfaces.d.ts\"/>\r\n\"use strict\";\r\nvar __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar fs = require('fs');\r\nvar path = require('path');\r\nvar grunt = require('grunt');\r\nvar _str = require('underscore.string');\r\nvar _ = require('lodash');\r\nvar utils = require('./utils');\r\n// Setup when transformers are triggered\r\nvar currentTargetFiles;\r\nvar currentTargetDirs;\r\n// Based on name\r\n// if a filename matches we return a filepath\r\n// If a foldername matches we return a folderpath\r\nfunction getImports(currentFilePath, name, targetFiles, targetDirs, getIndexIfDir) {\r\n    if (getIndexIfDir === void 0) { getIndexIfDir = true; }\r\n    var files = [];\r\n    // Test if any filename matches\r\n    var targetFile = _.find(targetFiles, function (targetFile) {\r\n        return path.basename(targetFile) === name\r\n            || path.basename(targetFile, '.d.ts') === name\r\n            || path.basename(targetFile, '.ts') === name;\r\n    });\r\n    if (targetFile) {\r\n        files.push(targetFile);\r\n    }\r\n    // It might be worthwhile to cache this lookup\r\n    // i.e. have a 'foldername':folderpath map passed in\r\n    // Test if dirname matches\r\n    var targetDir = _.find(targetDirs, function (targetDir) {\r\n        return path.basename(targetDir) === name;\r\n    });\r\n    if (targetDir) {\r\n        var possibleIndexFilePath = path.join(targetDir, 'index.ts');\r\n        // If targetDir has an index file AND this is not that file then\r\n        // use index.ts instead of all the files in the directory\r\n        if (getIndexIfDir\r\n            && fs.existsSync(possibleIndexFilePath)\r\n            && path.relative(currentFilePath, possibleIndexFilePath) !== '') {\r\n            files.push(path.join(targetDir, 'index.ts'));\r\n        }\r\n        else {\r\n            var filesInDir = utils.getFiles(targetDir, function (filename) {\r\n                // exclude current file\r\n                if (path.relative(currentFilePath, filename) === '') {\r\n                    return true;\r\n                }\r\n                return path.extname(filename) // must have extension : do not exclude directories\r\n                    && (!_str.endsWith(filename, '.ts') || _str.endsWith(filename, '.d.ts'))\r\n                    && !fs.lstatSync(filename).isDirectory(); // for people that name directories with dots\r\n            });\r\n            filesInDir.sort(); // Sort needed to increase reliability of codegen between runs\r\n            files = files.concat(filesInDir);\r\n        }\r\n    }\r\n    return files;\r\n}\r\n// Algo\r\n// Notice that the file globs come as\r\n// test/fail/ts/deep/work.ts\r\n// So simply get dirname recursively till reach root '.'\r\nfunction getTargetFolders(targetFiles) {\r\n    var folders = {};\r\n    _.forEach(targetFiles, function (targetFile) {\r\n        var dir = path.dirname(targetFile);\r\n        while (dir !== '.' && !(dir in folders)) {\r\n            // grunt.log.writeln(dir);\r\n            folders[dir] = true;\r\n            dir = path.dirname(dir);\r\n        }\r\n    });\r\n    return Object.keys(folders);\r\n}\r\nvar BaseTransformer = (function () {\r\n    function BaseTransformer(key, variableSyntax) {\r\n        this.key = key;\r\n        this.match = new RegExp(utils.format(BaseTransformer.tsTransformerMatch, key));\r\n        this.signature = this.tripleSlashTS() + key;\r\n        this.signatureGenerated = this.signature + ':generated';\r\n        this.syntaxError = '/// Invalid syntax for ts:' + this.key + '=' + variableSyntax + ' ' + this.signatureGenerated;\r\n    }\r\n    BaseTransformer.prototype.tripleSlashTS = function () {\r\n        // This is a function and broken into two strings to prevent the transformers module from\r\n        // transforming *itself* (a-la Skynet).\r\n        return '//' + '/ts:';\r\n    };\r\n    BaseTransformer.prototype.isGenerated = function (line) {\r\n        return _str.contains(line, this.signatureGenerated);\r\n    };\r\n    BaseTransformer.prototype.matches = function (line) {\r\n        return line.match(this.match);\r\n    };\r\n    BaseTransformer.containsTransformSignature = function (line) {\r\n        return BaseTransformer.tsSignatureMatch.test(line);\r\n    };\r\n    BaseTransformer.tsSignatureMatch = /\\/\\/\\/\\s*ts\\:/;\r\n    // equals sign is optional because we want to match on the signature regardless of any errors,\r\n    // transformFiles() checks that the equals sign exists (by checking for the first matched capture group)\r\n    // and fails if it is not found.\r\n    BaseTransformer.tsTransformerMatch = '^///\\\\s*ts:{0}(=?)(.*)';\r\n    return BaseTransformer;\r\n}());\r\n// This is a separate class from BaseTransformer to make it easier to add non import/export transforms in the future\r\nvar BaseImportExportTransformer = (function (_super) {\r\n    __extends(BaseImportExportTransformer, _super);\r\n    function BaseImportExportTransformer(key, variableSyntax, template, getIndexIfDir, removeExtensionFromFilePath) {\r\n        _super.call(this, key, variableSyntax);\r\n        this.key = key;\r\n        this.template = template;\r\n        this.getIndexIfDir = getIndexIfDir;\r\n        this.removeExtensionFromFilePath = removeExtensionFromFilePath;\r\n    }\r\n    BaseImportExportTransformer.prototype.transform = function (sourceFile, templateVars) {\r\n        var _this = this;\r\n        var result = [];\r\n        if (templateVars) {\r\n            var vars = templateVars.split(',');\r\n            var requestedFileName = vars[0].trim();\r\n            var requestedVariableName = (vars.length > 1 ? vars[1].trim() : null);\r\n            var sourceFileDirectory = path.dirname(sourceFile);\r\n            var imports = getImports(sourceFile, requestedFileName, currentTargetFiles, currentTargetDirs, this.getIndexIfDir);\r\n            if (imports.length) {\r\n                _.forEach(imports, function (completePathToFile) {\r\n                    var filename = requestedVariableName || path.basename(path.basename(completePathToFile, '.ts'), '.d');\r\n                    // If filename is index, we replace it with dirname:\r\n                    if (filename.toLowerCase() === 'index') {\r\n                        filename = path.basename(path.dirname(completePathToFile));\r\n                    }\r\n                    var pathToFile = utils.makeRelativePath(sourceFileDirectory, _this.removeExtensionFromFilePath ? completePathToFile.replace(/(?:\\.d)?\\.ts$/, '') : completePathToFile, true);\r\n                    result.push(_this.template({ filename: filename, pathToFile: pathToFile, signatureGenerated: _this.signatureGenerated })\r\n                        + ' '\r\n                        + _this.signatureGenerated);\r\n                });\r\n            }\r\n            else {\r\n                result.push('/// No file or directory matched name \"' + requestedFileName + '\" ' + this.signatureGenerated);\r\n            }\r\n        }\r\n        else {\r\n            result.push(this.syntaxError);\r\n        }\r\n        return result;\r\n    };\r\n    return BaseImportExportTransformer;\r\n}(BaseTransformer));\r\nvar ImportTransformer = (function (_super) {\r\n    __extends(ImportTransformer, _super);\r\n    function ImportTransformer() {\r\n        _super.call(this, 'import', '<fileOrDirectoryName>[,<variableName>]', _.template('import <%=filename%> = require(\\'<%= pathToFile %>\\');'), true, true);\r\n    }\r\n    return ImportTransformer;\r\n}(BaseImportExportTransformer));\r\nvar ExportTransformer = (function (_super) {\r\n    __extends(ExportTransformer, _super);\r\n    function ExportTransformer(eol) {\r\n        // This code is same as import transformer\r\n        // One difference : we do not short circuit to `index.ts` if found\r\n        _super.call(this, 'export', '<fileOrDirectoryName>[,<variableName>]', \r\n        // workaround for https://github.com/Microsoft/TypeScript/issues/512\r\n        _.template('import <%=filename%>_file = require(\\'<%= pathToFile %>\\'); <%= signatureGenerated %>' + eol +\r\n            'export var <%=filename%> = <%=filename%>_file;'), false, true);\r\n        this.eol = eol;\r\n    }\r\n    return ExportTransformer;\r\n}(BaseImportExportTransformer));\r\nvar ReferenceTransformer = (function (_super) {\r\n    __extends(ReferenceTransformer, _super);\r\n    function ReferenceTransformer() {\r\n        // This code is same as export transformer\r\n        // also we preserve .ts file extension\r\n        _super.call(this, 'ref', '<fileOrDirectoryName>', _.template('/// <reference path=\"<%= pathToFile %>\"/>'), false, false);\r\n    }\r\n    return ReferenceTransformer;\r\n}(BaseImportExportTransformer));\r\nvar UnknownTransformer = (function (_super) {\r\n    __extends(UnknownTransformer, _super);\r\n    function UnknownTransformer() {\r\n        _super.call(this, '(.*)', '');\r\n        this.key = 'unknown';\r\n        this.signatureGenerated = this.tripleSlashTS() + 'unknown:generated';\r\n        this.syntaxError = '/// Unknown transform ' + this.signatureGenerated;\r\n    }\r\n    UnknownTransformer.prototype.transform = function (sourceFile, templateVars) {\r\n        return [this.syntaxError];\r\n    };\r\n    return UnknownTransformer;\r\n}(BaseTransformer));\r\n// This code fixes the line encoding to be per os.\r\n// I think it is the best option available at the moment.\r\n// I am open for suggestions\r\nfunction transformFiles(changedFiles, targetFiles, options) {\r\n    currentTargetDirs = getTargetFolders(targetFiles);\r\n    currentTargetFiles = targetFiles;\r\n    ///////////////////////////////////// transformation\r\n    var transformers = [\r\n        new ImportTransformer(),\r\n        new ExportTransformer((options.newLine || utils.eol)),\r\n        new ReferenceTransformer(),\r\n        new UnknownTransformer()\r\n    ];\r\n    _.forEach(changedFiles, function (fileToProcess) {\r\n        var contents = fs.readFileSync(fileToProcess).toString().replace(/^\\uFEFF/, '');\r\n        // If no signature don't bother with this file\r\n        if (!BaseTransformer.containsTransformSignature(contents)) {\r\n            return;\r\n        }\r\n        var lines = contents.split(/\\r\\n|\\r|\\n/);\r\n        var outputLines = [];\r\n        for (var i = 0; i < lines.length; i++) {\r\n            var line = lines[i];\r\n            //// Debugging\r\n            // grunt.log.writeln('line'.green);\r\n            // grunt.log.writeln(line);\r\n            // Skip generated lines as these will get regenerated\r\n            if (_.some(transformers, function (transformer) { return transformer.isGenerated(line); })) {\r\n                continue;\r\n            }\r\n            // Directive line\r\n            if (_.some(transformers, function (transformer) {\r\n                var match = transformer.matches(line);\r\n                if (match) {\r\n                    // The code gen directive line automatically qualifies\r\n                    outputLines.push(line);\r\n                    // pass transform settings to transform (match[1] is the equals sign, ensure it exists but otherwise ignore it)\r\n                    outputLines.push.apply(outputLines, transformer.transform(fileToProcess, match[1] && match[2] && match[2].trim()));\r\n                    return true;\r\n                }\r\n                return false;\r\n            })) {\r\n                continue;\r\n            }\r\n            // Lines not generated or not directives\r\n            outputLines.push(line);\r\n        }\r\n        var transformedContent = outputLines.join(utils.eol);\r\n        if (transformedContent !== contents) {\r\n            grunt.file.write(fileToProcess, transformedContent);\r\n        }\r\n    });\r\n}\r\nexports.transformFiles = transformFiles;\r\n//# sourceMappingURL=transformers.js.map","/home/travis/build/npmtest/node-npmtest-grunt-ts/node_modules/grunt-ts/tasks/modules/optionsResolver.js":"/// <reference path=\"../../defs/tsd.d.ts\"/>\r\n/// <reference path=\"./interfaces.d.ts\"/>\r\n'use strict';\r\nvar defaults_1 = require('./defaults');\r\nvar utils = require('./utils');\r\nvar _ = require('lodash');\r\nvar es6_promise_1 = require('es6-promise');\r\nvar visualStudioOptionsResolver_1 = require('./visualStudioOptionsResolver');\r\nvar tsconfig_1 = require('./tsconfig');\r\n// Compiler Options documentation:\r\n// https://github.com/Microsoft/TypeScript-Handbook/blob/master/pages/Compiler%20Options.md\r\nvar propertiesFromTarget = ['amdloader', 'baseDir', 'html', 'htmlOutDir', 'htmlOutDirFlatten', 'reference', 'testExecute', 'tsconfig',\r\n    'templateCache', 'vs', 'watch'], \r\n// purposefully not supported: help, version, charset, diagnostics, listFiles\r\n// supported via other code: out, outDir, outFile, project\r\npropertiesFromTargetOptions = ['additionalFlags', 'allowSyntheticDefaultImports', 'comments', 'compile', 'compiler', 'declaration',\r\n    'emitBOM', 'emitDecoratorMetadata', 'experimentalDecorators', 'failOnTypeErrors', 'fast', 'htmlModuleTemplate', 'htmlOutDir',\r\n    'htmlOutputTemplate', 'htmlOutDirFlatten', 'htmlVarTemplate', 'inlineSourceMap', 'inlineSources', 'isolatedModules', 'locale',\r\n    'mapRoot', 'module', 'newLine', 'noEmit', 'noEmitHelpers', 'noEmitOnError', 'noImplicitAny', 'noLib', 'noResolve',\r\n    'preserveConstEnums', 'removeComments', 'sourceRoot', 'sourceMap', 'stripInternal', 'suppressExcessPropertyErrors',\r\n    'suppressImplicitAnyIndexErrors', 'target', 'verbose', 'jsx', 'moduleResolution', 'experimentalAsyncFunctions', 'rootDir',\r\n    'emitGruntEvents', 'reactNamespace', 'skipDefaultLibCheck', 'pretty', 'allowUnusedLabels', 'noImplicitReturns',\r\n    'noFallthroughCasesInSwitch', 'allowUnreachableCode', 'forceConsistentCasingInFileNames', 'allowJs', 'noImplicitUseStrict'], delayTemplateExpansion = ['htmlModuleTemplate', 'htmlVarTemplate', 'htmlOutputTemplate'];\r\nvar templateProcessor = null;\r\nvar globExpander = null;\r\nfunction noopTemplateProcessor(templateString, options) {\r\n    return templateString;\r\n}\r\nfunction emptyGlobExpander(globs) {\r\n    return [];\r\n}\r\nemptyGlobExpander.isStub = true;\r\nfunction resolveAsync(rawTaskOptions, rawTargetOptions, targetName, resolvedFiles, theTemplateProcessor, theGlobExpander) {\r\n    if (targetName === void 0) { targetName = ''; }\r\n    if (resolvedFiles === void 0) { resolvedFiles = []; }\r\n    if (theTemplateProcessor === void 0) { theTemplateProcessor = null; }\r\n    if (theGlobExpander === void 0) { theGlobExpander = null; }\r\n    var result = emptyOptionsResolveResult();\r\n    return new es6_promise_1.Promise(function (resolve, reject) {\r\n        if (theTemplateProcessor && typeof theTemplateProcessor === 'function') {\r\n            templateProcessor = theTemplateProcessor;\r\n        }\r\n        else {\r\n            templateProcessor = noopTemplateProcessor;\r\n        }\r\n        if (theGlobExpander && typeof theGlobExpander === 'function') {\r\n            globExpander = theGlobExpander;\r\n        }\r\n        else {\r\n            globExpander = emptyGlobExpander;\r\n        }\r\n        fixMissingOptions(rawTaskOptions);\r\n        fixMissingOptions(rawTargetOptions);\r\n        {\r\n            var _a = resolveAndWarnOnConfigurationIssues(rawTaskOptions, rawTargetOptions, targetName), errors = _a.errors, warnings = _a.warnings;\r\n            (_b = result.errors).push.apply(_b, errors);\r\n            (_c = result.warnings).push.apply(_c, warnings);\r\n        }\r\n        result = applyGruntOptions(result, rawTaskOptions);\r\n        result = applyGruntOptions(result, rawTargetOptions);\r\n        result = copyCompilationTasks(result, resolvedFiles, resolveOutputOptions(rawTaskOptions, rawTargetOptions));\r\n        visualStudioOptionsResolver_1.resolveVSOptionsAsync(result, rawTaskOptions, rawTargetOptions, templateProcessor).then(function (result) {\r\n            tsconfig_1.resolveAsync(result, rawTaskOptions, rawTargetOptions, templateProcessor, globExpander).then(function (result) {\r\n                result = addressAssociatedOptionsAndResolveConflicts(result);\r\n                result = enclosePathsInQuotesIfRequired(result);\r\n                result = logAdditionalConfigurationWarnings(result);\r\n                result = applyGruntTSDefaults(result);\r\n                if (result.targetName === undefined ||\r\n                    (!result.targetName && targetName)) {\r\n                    result.targetName = targetName;\r\n                }\r\n                return resolve(result);\r\n            }).catch(function (tsConfigError) {\r\n                result.errors.push('tsconfig error: ' + JSON.stringify(tsConfigError));\r\n                return resolve(result);\r\n            });\r\n        }).catch(function (vsConfigError) {\r\n            result.errors.push('Visual Studio config issue: ' + JSON.stringify(vsConfigError));\r\n            return resolve(result);\r\n        });\r\n        var _b, _c;\r\n    });\r\n}\r\nexports.resolveAsync = resolveAsync;\r\nfunction resolveOutputOptions(rawTaskOptions, rawTargetOptions) {\r\n    var result = {};\r\n    var props = ['outDir', 'out'];\r\n    var options = [rawTaskOptions, rawTargetOptions];\r\n    options.forEach(function (opt) {\r\n        props.forEach(function (prop) {\r\n            if (opt && (prop in opt)) {\r\n                result[prop] = opt[prop];\r\n            }\r\n        });\r\n    });\r\n    return result;\r\n}\r\nfunction fixMissingOptions(config) {\r\n    if (config && !config.options) {\r\n        config.options = {};\r\n    }\r\n}\r\nfunction emptyOptionsResolveResult() {\r\n    return {\r\n        warnings: [],\r\n        errors: []\r\n    };\r\n}\r\nfunction logAdditionalConfigurationWarnings(options) {\r\n    return options;\r\n}\r\nfunction resolveAndWarnOnConfigurationIssues(task, target, targetName) {\r\n    var errors = [], warnings = [];\r\n    var lowercaseTargetProps = _.map(propertiesFromTarget, function (prop) { return prop.toLocaleLowerCase(); });\r\n    var lowercaseTargetOptionsProps = _.map(propertiesFromTargetOptions, function (prop) { return prop.toLocaleLowerCase(); });\r\n    checkFixableCaseIssues(task, 'ts task');\r\n    checkFixableCaseIssues(target, \"target \\\"\" + targetName + \"\\\"\");\r\n    checkLocations(task, 'ts task');\r\n    checkLocations(target, \"target \\\"\" + targetName + \"\\\"\");\r\n    fixFilesUsedWithFast(task, 'ts task');\r\n    fixFilesUsedWithFast(target, \"target \\\"\" + targetName + \"\\\"\");\r\n    warnings.push.apply(warnings, getAdditionalWarnings(task, target, targetName));\r\n    return { errors: errors, warnings: warnings };\r\n    function getAdditionalWarnings(task, target, targetName) {\r\n        var additionalWarnings = [];\r\n        if (propertiesFromTarget.indexOf(targetName) >= 0) {\r\n            additionalWarnings.push((\"Warning: Using the grunt-ts keyword \\\"\" + targetName + \"\\\" as a target name may cause \") +\r\n                \"incorrect behavior or errors.\");\r\n        }\r\n        if (((task && task.src && targetName !== 'src') || (target && target.src)) &&\r\n            ((task && task.files) || (target && target.files))) {\r\n            additionalWarnings.push(\"Warning: In task \\\"\" + targetName + \"\\\", either \\\"files\\\" or \\\"src\\\" should be used - not both.\");\r\n        }\r\n        if (((task && task.vs) || (target && target.vs)) &&\r\n            ((task && task.files) || (target && target.files))) {\r\n            additionalWarnings.push(\"Warning: In task \\\"\" + targetName + \"\\\", either \\\"files\\\" or \\\"vs\\\" should be used - not both.\");\r\n        }\r\n        if (usingDestArray(task) || usingDestArray(target)) {\r\n            additionalWarnings.push((\"Warning: target \\\"\" + targetName + \"\\\" has an array specified for the files.dest property.\") +\r\n                \"  This is not supported.  Taking first element and ignoring the rest.\");\r\n        }\r\n        if ((task && task.outFile) || (target && target.outFile)) {\r\n            additionalWarnings.push((\"Warning: target \\\"\" + targetName + \"\\\" is using \\\"outFile\\\".  This is not supported by\") +\r\n                \" grunt-ts via the Gruntfile - it's only relevant when present in tsconfig.json file.  Use \\\"out\\\" instead.\");\r\n        }\r\n        return additionalWarnings;\r\n        function usingDestArray(task) {\r\n            var result = false;\r\n            if (task && task.files && _.isArray(task.files)) {\r\n                task.files.forEach(function (item) {\r\n                    if (_.isArray(item.dest)) {\r\n                        result = true;\r\n                    }\r\n                    ;\r\n                });\r\n            }\r\n            return result;\r\n        }\r\n    }\r\n    function fixFilesUsedWithFast(task, configName) {\r\n        if (task && task.files && task.options && task.options.fast) {\r\n            warnings.push((\"Warning: \" + configName + \" is attempting to use fast compilation with \\\"files\\\".  \") +\r\n                \"This is not currently supported.  Setting \\\"fast\\\" to \\\"never\\\".\");\r\n            task.options.fast = 'never';\r\n        }\r\n    }\r\n    function checkLocations(task, configName) {\r\n        // todo: clean this up.  The top and bottom sections are largely the same.\r\n        if (task) {\r\n            for (var propertyName in task) {\r\n                if (propertiesFromTarget.indexOf(propertyName) === -1 && propertyName !== 'options') {\r\n                    if (propertiesFromTargetOptions.indexOf(propertyName) > -1) {\r\n                        var warningText = (\"Property \\\"\" + propertyName + \"\\\" in \" + configName + \" is possibly in the wrong place and will be ignored.  \") +\r\n                            \"It is expected on the options object.\";\r\n                        warnings.push(warningText);\r\n                    }\r\n                    else if (lowercaseTargetProps.indexOf(propertyName.toLocaleLowerCase()) === -1\r\n                        && lowercaseTargetOptionsProps.indexOf(propertyName.toLocaleLowerCase()) > -1) {\r\n                        var index = lowercaseTargetOptionsProps.indexOf(propertyName.toLocaleLowerCase());\r\n                        var correctPropertyName = propertiesFromTargetOptions[index];\r\n                        var warningText = (\"Property \\\"\" + propertyName + \"\\\" in \" + configName + \" is possibly in the wrong place and will be ignored.  \") +\r\n                            (\"It is expected on the options object.  It is also the wrong case and should be \" + correctPropertyName + \".\");\r\n                        warnings.push(warningText);\r\n                    }\r\n                }\r\n            }\r\n            if (task.options) {\r\n                for (var propertyName in task.options) {\r\n                    if (propertiesFromTargetOptions.indexOf(propertyName) === -1) {\r\n                        if (propertiesFromTarget.indexOf(propertyName) > -1) {\r\n                            var warningText = (\"Property \\\"\" + propertyName + \"\\\" in \" + configName + \" is possibly in the wrong place and will be ignored.  \") +\r\n                                \"It is expected on the task or target, not under options.\";\r\n                            warnings.push(warningText);\r\n                        }\r\n                        else if (lowercaseTargetOptionsProps.indexOf(propertyName.toLocaleLowerCase()) === -1\r\n                            && lowercaseTargetProps.indexOf(propertyName.toLocaleLowerCase()) > -1) {\r\n                            var index = lowercaseTargetProps.indexOf(propertyName.toLocaleLowerCase());\r\n                            var correctPropertyName = propertiesFromTarget[index];\r\n                            var warningText = (\"Property \\\"\" + propertyName + \"\\\" in \" + configName + \" is possibly in the wrong place and will be ignored.  \") +\r\n                                (\"It is expected on the task or target, not under options.  It is also the wrong case and should be \" + correctPropertyName + \".\");\r\n                            warnings.push(warningText);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    function checkFixableCaseIssues(task, configName) {\r\n        if (task) {\r\n            for (var propertyName in task) {\r\n                if ((propertiesFromTarget.indexOf(propertyName) === -1)\r\n                    && (lowercaseTargetProps.indexOf(propertyName.toLocaleLowerCase()) > -1)\r\n                    && (propertiesFromTargetOptions.indexOf(propertyName) === -1)) {\r\n                    var index = lowercaseTargetProps.indexOf(propertyName.toLocaleLowerCase());\r\n                    var correctPropertyName = propertiesFromTarget[index];\r\n                    var warningText = (\"Property \\\"\" + propertyName + \"\\\" in \" + configName + \" is incorrectly cased; it should \") +\r\n                        (\"be \\\"\" + correctPropertyName + \"\\\".  Fixing it for you and proceeding.\");\r\n                    warnings.push(warningText);\r\n                    task[correctPropertyName] = task[propertyName];\r\n                    delete task[propertyName];\r\n                }\r\n            }\r\n            for (var propertyName in task.options) {\r\n                if ((propertiesFromTargetOptions.indexOf(propertyName) === -1)\r\n                    && (lowercaseTargetOptionsProps.indexOf(propertyName.toLocaleLowerCase()) > -1)\r\n                    && (propertiesFromTarget.indexOf(propertyName) === -1)) {\r\n                    var index = lowercaseTargetOptionsProps.indexOf(propertyName.toLocaleLowerCase());\r\n                    var correctPropertyName = propertiesFromTargetOptions[index];\r\n                    var warningText = (\"Property \\\"\" + propertyName + \"\\\" in \" + configName + \" options is incorrectly cased; it should \") +\r\n                        (\"be \\\"\" + correctPropertyName + \"\\\".  Fixing it for you and proceeding.\");\r\n                    warnings.push(warningText);\r\n                    task.options[correctPropertyName] = task.options[propertyName];\r\n                    delete task.options[propertyName];\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction applyGruntOptions(applyTo, gruntOptions) {\r\n    if (gruntOptions) {\r\n        for (var _i = 0, propertiesFromTarget_1 = propertiesFromTarget; _i < propertiesFromTarget_1.length; _i++) {\r\n            var propertyName = propertiesFromTarget_1[_i];\r\n            if (propertyName in gruntOptions && propertyName !== 'vs') {\r\n                if (typeof gruntOptions[propertyName] === 'string' && utils.hasValue(gruntOptions[propertyName]) &&\r\n                    delayTemplateExpansion.indexOf(propertyName) === -1) {\r\n                    applyTo[propertyName] = templateProcessor(gruntOptions[propertyName], {});\r\n                }\r\n                else {\r\n                    applyTo[propertyName] = gruntOptions[propertyName];\r\n                }\r\n            }\r\n        }\r\n        if (gruntOptions.options) {\r\n            for (var _a = 0, propertiesFromTargetOptions_1 = propertiesFromTargetOptions; _a < propertiesFromTargetOptions_1.length; _a++) {\r\n                var propertyName = propertiesFromTargetOptions_1[_a];\r\n                if (propertyName in gruntOptions.options) {\r\n                    if (typeof gruntOptions.options[propertyName] === 'string' && utils.hasValue(gruntOptions.options[propertyName]) &&\r\n                        delayTemplateExpansion.indexOf(propertyName) === -1) {\r\n                        applyTo[propertyName] = templateProcessor(gruntOptions.options[propertyName], {});\r\n                    }\r\n                    else {\r\n                        applyTo[propertyName] = gruntOptions.options[propertyName];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return applyTo;\r\n}\r\nfunction copyCompilationTasks(options, resolvedFiles, outputInfo) {\r\n    if (!utils.hasValue(options.CompilationTasks)) {\r\n        options.CompilationTasks = [];\r\n    }\r\n    if (!utils.hasValue(resolvedFiles) || resolvedFiles.length === 0) {\r\n        if (options.CompilationTasks.length === 0 && (('outDir' in outputInfo) || ('out' in outputInfo))) {\r\n            var newCompilationTask = {\r\n                src: []\r\n            };\r\n            if ('outDir' in outputInfo) {\r\n                newCompilationTask.outDir = outputInfo.outDir;\r\n            }\r\n            if ('out' in outputInfo) {\r\n                newCompilationTask.outDir = outputInfo.outDir;\r\n            }\r\n            options.CompilationTasks.push(newCompilationTask);\r\n        }\r\n        return options;\r\n    }\r\n    for (var i = 0; i < resolvedFiles.length; i += 1) {\r\n        var glob = void 0;\r\n        var orig = resolvedFiles[i].orig;\r\n        if (orig && ('src' in orig)) {\r\n            glob = [].concat(orig.src);\r\n        }\r\n        var compilationSet = {\r\n            src: _.map(resolvedFiles[i].src, function (fileName) { return utils.enclosePathInQuotesIfRequired(fileName); }),\r\n            out: utils.enclosePathInQuotesIfRequired(resolvedFiles[i].out),\r\n            outDir: utils.enclosePathInQuotesIfRequired(resolvedFiles[i].outDir),\r\n            glob: glob\r\n        };\r\n        if ('dest' in resolvedFiles[i] && resolvedFiles[i].dest) {\r\n            var dest = void 0;\r\n            if (_.isArray(resolvedFiles[i].dest)) {\r\n                // using an array for dest is not supported.  Only take first element.\r\n                dest = resolvedFiles[i].dest[0];\r\n            }\r\n            else {\r\n                dest = resolvedFiles[i].dest;\r\n            }\r\n            if (utils.isJavaScriptFile(dest)) {\r\n                compilationSet.out = dest;\r\n            }\r\n            else {\r\n                compilationSet.outDir = dest;\r\n            }\r\n        }\r\n        options.CompilationTasks.push(compilationSet);\r\n    }\r\n    return options;\r\n}\r\nfunction enclosePathsInQuotesIfRequired(options) {\r\n    if (options.rootDir) {\r\n        options.rootDir = utils.enclosePathInQuotesIfRequired(options.rootDir);\r\n    }\r\n    if (options.mapRoot) {\r\n        options.mapRoot = utils.enclosePathInQuotesIfRequired(options.mapRoot);\r\n    }\r\n    if (options.sourceRoot) {\r\n        options.sourceRoot = utils.enclosePathInQuotesIfRequired(options.sourceRoot);\r\n    }\r\n    return options;\r\n}\r\nfunction addressAssociatedOptionsAndResolveConflicts(options) {\r\n    if (options.emitDecoratorMetadata) {\r\n        options.experimentalDecorators = true;\r\n    }\r\n    if (options.inlineSourceMap && options.sourceMap) {\r\n        options.warnings.push('TypeScript cannot use inlineSourceMap and sourceMap together.  Ignoring sourceMap.');\r\n        options.sourceMap = false;\r\n    }\r\n    if (options.inlineSources && !options.sourceMap) {\r\n        options.inlineSources = true;\r\n        options.inlineSourceMap = true;\r\n        options.sourceMap = false;\r\n    }\r\n    if ('comments' in options && 'removeComments' in options) {\r\n        options.warnings.push(\"WARNING: Option \\\"comments\\\" and \\\"removeComments\\\" should not be used together.  \" +\r\n            (\"The --removeComments value of \" + !!options.removeComments + \" supercedes the --comments value of \" + !!options.comments));\r\n    }\r\n    if ('comments' in options && !('removeComments' in options)) {\r\n        options.comments = !!options.comments;\r\n        options.removeComments = !options.comments;\r\n    }\r\n    else if (!('comments' in options) && ('removeComments' in options)) {\r\n        options.removeComments = !!options.removeComments;\r\n        options.comments = !options.removeComments;\r\n    }\r\n    if ('html' in options &&\r\n        (options.CompilationTasks.length === 0 ||\r\n            !_.some(options.CompilationTasks, function (item) { return ((item.src || []).length > 0 || (item.glob || []).length > 0); }))) {\r\n        options.errors.push(\"ERROR: option \\\"html\\\" provided without corresponding TypeScript source files or glob to \" +\r\n            \"compile.  The transform will not occur unless grunt-ts also expects to compile some files.\");\r\n    }\r\n    options.CompilationTasks.forEach(function (compileTask) {\r\n        if (compileTask.out && compileTask.outDir) {\r\n            options.warnings.push('The parameter `out` is incompatible with `outDir`; pass one or the other - not both.  Ignoring `out` and using `outDir`.');\r\n            compileTask.out = '';\r\n        }\r\n    });\r\n    return options;\r\n}\r\nfunction applyGruntTSDefaults(options) {\r\n    if (!('sourceMap' in options) && !('inlineSourceMap' in options)) {\r\n        options.sourceMap = defaults_1.GruntTSDefaults.sourceMap;\r\n    }\r\n    if (!('target' in options)) {\r\n        options.target = defaults_1.GruntTSDefaults.target;\r\n    }\r\n    if (!('fast' in options)) {\r\n        options.fast = defaults_1.GruntTSDefaults.fast;\r\n    }\r\n    if (!('compile' in options)) {\r\n        options.compile = defaults_1.GruntTSDefaults.compile;\r\n    }\r\n    if (!('htmlOutDir' in options)) {\r\n        options.htmlOutDir = null;\r\n    }\r\n    if (!('htmlOutDirFlatten' in options)) {\r\n        options.htmlOutDirFlatten = defaults_1.GruntTSDefaults.htmlOutDirFlatten;\r\n    }\r\n    if (!('htmlModuleTemplate' in options)) {\r\n        options.htmlModuleTemplate = defaults_1.GruntTSDefaults.htmlModuleTemplate;\r\n    }\r\n    if (!('htmlVarTemplate' in options)) {\r\n        options.htmlVarTemplate = defaults_1.GruntTSDefaults.htmlVarTemplate;\r\n    }\r\n    if (!('removeComments' in options) && !('comments' in options)) {\r\n        options.removeComments = defaults_1.GruntTSDefaults.removeComments;\r\n    }\r\n    if (!('failOnTypeErrors' in options)) {\r\n        options.failOnTypeErrors = defaults_1.GruntTSDefaults.failOnTypeErrors;\r\n    }\r\n    if (!('emitGruntEvents' in options)) {\r\n        options.emitGruntEvents = defaults_1.GruntTSDefaults.emitGruntEvents;\r\n    }\r\n    return options;\r\n}\r\n//# sourceMappingURL=optionsResolver.js.map","/home/travis/build/npmtest/node-npmtest-grunt-ts/node_modules/grunt-ts/tasks/modules/defaults.js":"'use strict';\r\nvar utils = require('./utils');\r\nvar _ = require('lodash');\r\nvar TypeScriptDefaults = {\r\n    allowBool: false,\r\n    allowImportModule: false,\r\n    allowSyntheticDefaultImports: null,\r\n    amdloader: null,\r\n    compile: true,\r\n    declaration: false,\r\n    emitDecoratorMetadata: false,\r\n    experimentalDecorators: false,\r\n    mapRoot: '',\r\n    module: null,\r\n    noImplicitAny: false,\r\n    noResolve: false,\r\n    comments: null,\r\n    removeComments: null,\r\n    sourceMap: true,\r\n    sourceRoot: '',\r\n    target: null,\r\n    verbose: false,\r\n    fast: null,\r\n    watch: null,\r\n    compiler: '',\r\n    html: null,\r\n    htmlModuleTemplate: null,\r\n    htmlVarTemplate: null,\r\n    htmlOutputTemplate: null,\r\n    htmlOutDir: null,\r\n    htmlOutDirFlatten: null,\r\n    failOnTypeErrors: null,\r\n    emitGruntEvents: null,\r\n    noEmitOnError: false,\r\n    preserveConstEnums: false,\r\n    suppressExcessPropertyErrors: false,\r\n    suppressImplicitAnyIndexErrors: false,\r\n    stripInternal: false,\r\n    noEmit: false,\r\n    noLib: false,\r\n    emitBOM: false,\r\n    inlineSources: false,\r\n    inlineSourceMap: false,\r\n    newLine: utils.eol,\r\n    isolatedModules: false,\r\n    noEmitHelpers: false,\r\n    additionalFlags: '',\r\n    templateCache: null,\r\n    targetName: '',\r\n    locale: null,\r\n    jsx: null,\r\n    moduleResolution: null,\r\n    experimentalAsyncFunctions: null,\r\n    reactNamespace: null,\r\n    skipDefaultLibCheck: null,\r\n    pretty: false,\r\n    allowUnusedLabels: false,\r\n    noImplicitReturns: false,\r\n    noFallthroughCasesInSwitch: false,\r\n    allowUnreachableCode: false,\r\n    forceConsistentCasingInFileNames: false,\r\n    allowJs: false,\r\n    noImplicitUseStrict: false,\r\n    rootDir: null,\r\n    warnings: [],\r\n    errors: []\r\n};\r\nexports.GruntTSDefaults = applyGruntTSDefaults(_.clone(TypeScriptDefaults));\r\nfunction applyGruntTSDefaults(options) {\r\n    // this function applies defaults where grunt-ts differs from TypeScript\r\n    options.sourceMap = true;\r\n    options.target = 'es5';\r\n    options.htmlModuleTemplate = '<%= filename %>';\r\n    options.htmlVarTemplate = '<%= ext %>';\r\n    options.htmlOutDirFlatten = false;\r\n    options.fast = 'watch';\r\n    options.removeComments = true;\r\n    options.failOnTypeErrors = true;\r\n    options.emitGruntEvents = false;\r\n    return options;\r\n}\r\n//# sourceMappingURL=defaults.js.map","/home/travis/build/npmtest/node-npmtest-grunt-ts/node_modules/grunt-ts/tasks/modules/visualStudioOptionsResolver.js":"'use strict';\r\nvar csproj2ts = require('csproj2ts');\r\nvar path = require('path');\r\nvar utils = require('./utils');\r\nvar es6_promise_1 = require('es6-promise');\r\nvar _ = require('lodash');\r\nvar templateProcessor = null;\r\nfunction resolveVSOptionsAsync(applyTo, taskOptions, targetOptions, theTemplateProcessor) {\r\n    templateProcessor = theTemplateProcessor;\r\n    return new es6_promise_1.Promise(function (resolve, reject) {\r\n        {\r\n            var vsTask = getVSSettings(taskOptions), vsTarget = getVSSettings(targetOptions);\r\n            var vs = null;\r\n            if (vsTask) {\r\n                vs = vsTask;\r\n            }\r\n            if (vsTarget) {\r\n                if (!vs) {\r\n                    vs = vsTarget;\r\n                }\r\n                if (vsTarget.project) {\r\n                    vs.project = vsTarget.project;\r\n                }\r\n                if (vsTarget.config) {\r\n                    vs.config = vsTarget.config;\r\n                }\r\n                if (vsTarget.ignoreFiles) {\r\n                    vs.ignoreFiles = vsTarget.ignoreFiles;\r\n                }\r\n                if (vsTarget.ignoreSettings) {\r\n                    vs.ignoreSettings = vsTarget.ignoreSettings;\r\n                }\r\n            }\r\n            if (vs) {\r\n                applyTo.vs = vs;\r\n                if (typeof applyTo.vs.project === 'string') {\r\n                    applyTo.vs.project = templateProcessor(applyTo.vs.project, {});\r\n                }\r\n                if (typeof applyTo.vs.config === 'string') {\r\n                    applyTo.vs.config = templateProcessor(applyTo.vs.config, {});\r\n                }\r\n            }\r\n        }\r\n        if (applyTo.vs) {\r\n            return csproj2ts.getTypeScriptSettings({\r\n                ProjectFileName: applyTo.vs.project,\r\n                ActiveConfiguration: applyTo.vs.config || undefined\r\n            }).then(function (vsConfig) {\r\n                try {\r\n                    applyTo = applyVSOptions(applyTo, vsConfig);\r\n                    applyTo = resolve_out_and_outDir(applyTo, taskOptions, targetOptions);\r\n                    return resolve(applyTo);\r\n                }\r\n                catch (ex) {\r\n                    return reject(ex);\r\n                }\r\n            }).catch(function (error) {\r\n                if (error.errno === 34) {\r\n                    applyTo.errors.push('In target \"' + applyTo.targetName + '\" - could not find VS project at \"' + error.path + '\".');\r\n                }\r\n                else {\r\n                    applyTo.errors.push('In target \"' + applyTo.targetName + '\".  Error #' + error.errno + '.  ' + error);\r\n                }\r\n                return reject(error);\r\n            });\r\n        }\r\n        return resolve(applyTo);\r\n    });\r\n}\r\nexports.resolveVSOptionsAsync = resolveVSOptionsAsync;\r\nfunction resolve_out_and_outDir(options, taskOptions, targetOptions) {\r\n    if (options.CompilationTasks && options.CompilationTasks.length > 0) {\r\n        options.CompilationTasks.forEach(function (compilationTask) {\r\n            [taskOptions, targetOptions].forEach(function (optionSet) {\r\n                if (optionSet && optionSet.out) {\r\n                    compilationTask.out = optionSet.out;\r\n                }\r\n                if (optionSet && optionSet.outDir) {\r\n                    compilationTask.outDir = optionSet.outDir;\r\n                }\r\n            });\r\n        });\r\n    }\r\n    return options;\r\n}\r\nfunction applyVSOptions(options, vsSettings) {\r\n    var ignoreFiles = false, ignoreSettings = false;\r\n    if (typeof options.vs !== 'string') {\r\n        var vsOptions = options.vs;\r\n        ignoreFiles = !!vsOptions.ignoreFiles;\r\n        ignoreSettings = !!vsOptions.ignoreSettings;\r\n    }\r\n    if (!ignoreFiles) {\r\n        if (options.CompilationTasks.length === 0) {\r\n            options.CompilationTasks.push({ src: [] });\r\n        }\r\n        var src_1 = options.CompilationTasks[0].src;\r\n        var absolutePathToVSProjectFolder_1 = path.resolve(vsSettings.VSProjectDetails.ProjectFileName, '..');\r\n        var gruntfileFolder_1 = path.resolve('.');\r\n        _.map(_.uniq(vsSettings.files), function (file) {\r\n            var absolutePathToFile = path.normalize(path.join(absolutePathToVSProjectFolder_1, file));\r\n            var relativePathToFileFromGruntfile = path.relative(gruntfileFolder_1, absolutePathToFile).replace(new RegExp('\\\\' + path.sep, 'g'), '/');\r\n            if (src_1.indexOf(absolutePathToFile) === -1 &&\r\n                src_1.indexOf(relativePathToFileFromGruntfile) === -1) {\r\n                src_1.push(relativePathToFileFromGruntfile);\r\n            }\r\n        });\r\n    }\r\n    if (!ignoreSettings) {\r\n        options = applyVSSettings(options, vsSettings);\r\n    }\r\n    return options;\r\n}\r\nfunction relativePathToVSProjectFolderFromGruntfile(settings) {\r\n    return path.resolve(settings.VSProjectDetails.ProjectFileName, '..');\r\n}\r\nfunction applyVSSettings(options, vsSettings) {\r\n    // Visit this page for MSBuild documentation:\r\n    // https://github.com/Microsoft/TypeScript-Handbook/blob/master/pages/Compiler%20Options%20in%20MSBuild.md\r\n    var simpleVSSettingsToGruntTSMappings = {\r\n        'AllowSyntheticDefaultImports': 'allowSyntheticDefaultImports',\r\n        'AllowUnusedLabels': 'allowUnusedLabels',\r\n        'AllowUnreachableCode': 'allowUnreachableCode',\r\n        'EmitBOM': 'emitBom',\r\n        'EmitDecoratorMetadata': 'emitDecoratorMetadata',\r\n        'ExperimentalAsyncFunctions': 'experimentalAsyncFunctions',\r\n        'ExperimentalDecorators': 'experimentalDecorators',\r\n        'ForceConsistentCasingInFileNames': 'forceConsistentCasingInFileNames',\r\n        'GeneratesDeclarations': 'declaration',\r\n        'InlineSourceMap': 'inlineSourceMap',\r\n        'InlineSources': 'inlineSources',\r\n        'IsolatedModules': 'isolatedModules',\r\n        'JSXEmit': 'jsx',\r\n        'MapRoot': 'mapRoot',\r\n        'ModuleKind': 'module',\r\n        'ModuleResolution': 'moduleResolution',\r\n        'NewLine': 'newLine',\r\n        'NoEmitOnError': 'noEmitOnError',\r\n        'NoEmitHelpers': 'NoEmitHelpers',\r\n        'NoFallthroughCasesInSwitch': 'noFallthroughCasesInSwitch',\r\n        'NoImplicitAny': 'noImplicitAny',\r\n        'NoImplicitReturns': 'noImplicitReturns',\r\n        'noImplicitUseStrict': 'NoImplicitUseStrict',\r\n        'NoLib': 'noLib',\r\n        'NoResolve': 'noResolve',\r\n        // OutFile (both out and outFile) and OutDir are resolved elsewhere\r\n        'PreserveConstEnums': 'preserveConstEnums',\r\n        'ReactNamespace': 'reactNamespace',\r\n        'RemoveComments': 'removeComments',\r\n        'RootDir': 'rootDir',\r\n        'SkipDefaultLibCheck': 'skipDefaultLibCheck',\r\n        'SourceMap': 'sourceMap',\r\n        'SourceRoot': 'sourceRoot',\r\n        'SuppressImplicitAnyIndexErrors': 'suppressImplicitAnyIndexErrors',\r\n        'SuppressExcessPropertyErrors': 'suppressExcessPropertyErrors',\r\n        'Target': 'target'\r\n    };\r\n    for (var item in simpleVSSettingsToGruntTSMappings) {\r\n        if (!(simpleVSSettingsToGruntTSMappings[item] in options) && utils.hasValue(vsSettings[item])) {\r\n            options[simpleVSSettingsToGruntTSMappings[item]] = vsSettings[item];\r\n        }\r\n    }\r\n    if (!('module' in options) && utils.hasValue(vsSettings.ModuleKind)) {\r\n        options.module = vsSettings.ModuleKind;\r\n        if (options.module === 'none') {\r\n            options.module = undefined;\r\n        }\r\n    }\r\n    var gruntfileToProject = relativePathToVSProjectFolderFromGruntfile(vsSettings);\r\n    if (utils.hasValue(vsSettings.OutDir) && vsSettings.OutDir !== '') {\r\n        options.CompilationTasks.forEach(function (item) {\r\n            var absolutePath = path.resolve(gruntfileToProject, vsSettings.OutDir);\r\n            item.outDir = utils.enclosePathInQuotesIfRequired(path.relative(path.resolve('.'), absolutePath).replace(new RegExp('\\\\' + path.sep, 'g'), '/'));\r\n        });\r\n    }\r\n    if (utils.hasValue(vsSettings.OutFile) && vsSettings.OutFile !== '') {\r\n        options.CompilationTasks.forEach(function (item) {\r\n            var absolutePath = path.resolve(gruntfileToProject, vsSettings.OutFile);\r\n            item.out = utils.enclosePathInQuotesIfRequired(path.relative(path.resolve('.'), absolutePath).replace(new RegExp('\\\\' + path.sep, 'g'), '/'));\r\n        });\r\n    }\r\n    return options;\r\n}\r\nfunction getVSSettings(rawTargetOptions) {\r\n    var vs = null;\r\n    if (rawTargetOptions && rawTargetOptions.vs) {\r\n        var targetvs = rawTargetOptions.vs;\r\n        if (typeof targetvs === 'string') {\r\n            vs = {\r\n                project: targetvs,\r\n                config: '',\r\n                ignoreFiles: false,\r\n                ignoreSettings: false\r\n            };\r\n        }\r\n        else {\r\n            vs = {\r\n                project: targetvs.project || '',\r\n                config: targetvs.config || '',\r\n                ignoreFiles: targetvs.ignoreFiles || false,\r\n                ignoreSettings: targetvs.ignoreSettings || false\r\n            };\r\n        }\r\n    }\r\n    return vs;\r\n}\r\n//# sourceMappingURL=visualStudioOptionsResolver.js.map","/home/travis/build/npmtest/node-npmtest-grunt-ts/node_modules/grunt-ts/tasks/modules/tsconfig.js":"'use strict';\r\nvar es6_promise_1 = require('es6-promise');\r\nvar fs = require('fs');\r\nvar path = require('path');\r\nvar stripBom = require('strip-bom');\r\nvar _ = require('lodash');\r\nvar utils = require('./utils');\r\nvar templateProcessor = null;\r\nvar globExpander = null;\r\nvar gruntfileGlobs = null;\r\nvar absolutePathToTSConfig;\r\nfunction resolveAsync(applyTo, taskOptions, targetOptions, theTemplateProcessor, theGlobExpander) {\r\n    if (theGlobExpander === void 0) { theGlobExpander = null; }\r\n    templateProcessor = theTemplateProcessor;\r\n    globExpander = theGlobExpander;\r\n    gruntfileGlobs = getGlobs(taskOptions, targetOptions);\r\n    return new es6_promise_1.Promise(function (resolve, reject) {\r\n        try {\r\n            var taskTSConfig = getTSConfigSettings(taskOptions);\r\n            var targetTSConfig = getTSConfigSettings(targetOptions);\r\n            var tsconfig = null;\r\n            if (taskTSConfig) {\r\n                tsconfig = taskTSConfig;\r\n            }\r\n            if (targetTSConfig) {\r\n                if (!tsconfig) {\r\n                    tsconfig = targetTSConfig;\r\n                }\r\n                if ('tsconfig' in targetTSConfig) {\r\n                    tsconfig.tsconfig = templateProcessor(targetTSConfig.tsconfig, {});\r\n                }\r\n                if ('ignoreSettings' in targetTSConfig) {\r\n                    tsconfig.ignoreSettings = targetTSConfig.ignoreSettings;\r\n                }\r\n                if ('overwriteFilesGlob' in targetTSConfig) {\r\n                    tsconfig.overwriteFilesGlob = targetTSConfig.overwriteFilesGlob;\r\n                }\r\n                if ('updateFiles' in targetTSConfig) {\r\n                    tsconfig.updateFiles = targetTSConfig.updateFiles;\r\n                }\r\n                if ('passThrough' in targetTSConfig) {\r\n                    tsconfig.passThrough = targetTSConfig.passThrough;\r\n                }\r\n            }\r\n            applyTo.tsconfig = tsconfig;\r\n        }\r\n        catch (ex) {\r\n            return reject(ex);\r\n        }\r\n        if (!applyTo.tsconfig) {\r\n            return resolve(applyTo);\r\n        }\r\n        if (applyTo.tsconfig.passThrough) {\r\n            if (applyTo.CompilationTasks.length === 0) {\r\n                applyTo.CompilationTasks.push({ src: [] });\r\n            }\r\n            if (!applyTo.tsconfig.tsconfig) {\r\n                applyTo.tsconfig.tsconfig = '.';\r\n            }\r\n        }\r\n        else {\r\n            var projectFile = applyTo.tsconfig.tsconfig;\r\n            try {\r\n                var projectFileTextContent = fs.readFileSync(projectFile, 'utf8');\r\n            }\r\n            catch (ex) {\r\n                if (ex && ex.code === 'ENOENT') {\r\n                    return reject('Could not find file \"' + projectFile + '\".');\r\n                }\r\n                else if (ex && ex.errno) {\r\n                    return reject('Error ' + ex.errno + ' reading \"' + projectFile + '\".');\r\n                }\r\n                else {\r\n                    return reject('Error reading \"' + projectFile + '\": ' + JSON.stringify(ex));\r\n                }\r\n            }\r\n            try {\r\n                var projectSpec;\r\n                var content = stripBom(projectFileTextContent);\r\n                if (content.trim() === '') {\r\n                    projectSpec = {};\r\n                }\r\n                else {\r\n                    projectSpec = JSON.parse(content);\r\n                }\r\n            }\r\n            catch (ex) {\r\n                return reject('Error parsing \"' + projectFile + '\".  It may not be valid JSON in UTF-8.');\r\n            }\r\n            applyTo = warnOnBadConfiguration(applyTo, projectSpec);\r\n            applyTo = applyCompilerOptions(applyTo, projectSpec);\r\n            applyTo = resolve_output_locations(applyTo, projectSpec);\r\n        }\r\n        resolve(applyTo);\r\n    });\r\n}\r\nexports.resolveAsync = resolveAsync;\r\nfunction warnOnBadConfiguration(options, projectSpec) {\r\n    if (projectSpec.compilerOptions) {\r\n        if (projectSpec.compilerOptions.out && projectSpec.compilerOptions.outFile) {\r\n            options.warnings.push('Warning: `out` and `outFile` should not be used together in tsconfig.json.');\r\n        }\r\n        if (projectSpec.compilerOptions.out) {\r\n            options.warnings.push('Warning: Using `out` in tsconfig.json can be unreliable because it will output relative' +\r\n                ' to the tsc working directory.  It is better to use `outFile` which is always relative to tsconfig.json, ' +\r\n                ' but this requires TypeScript 1.6 or higher.');\r\n        }\r\n    }\r\n    return options;\r\n}\r\nfunction getGlobs(taskOptions, targetOptions) {\r\n    var globs = null;\r\n    if (taskOptions && isStringOrArray(taskOptions.src)) {\r\n        globs = _.map(getFlatCloneOf([taskOptions.src]), function (item) { return templateProcessor(item, {}); });\r\n    }\r\n    if (targetOptions && isStringOrArray(targetOptions.src)) {\r\n        globs = _.map(getFlatCloneOf([targetOptions.src]), function (item) { return templateProcessor(item, {}); });\r\n    }\r\n    return globs;\r\n    function isStringOrArray(thing) {\r\n        return (_.isArray(thing) || _.isString(thing));\r\n    }\r\n    function getFlatCloneOf(array) {\r\n        return _.flatten(array).slice();\r\n    }\r\n}\r\nfunction resolve_output_locations(options, projectSpec) {\r\n    if (options.CompilationTasks\r\n        && options.CompilationTasks.length > 0\r\n        && projectSpec\r\n        && projectSpec.compilerOptions) {\r\n        options.CompilationTasks.forEach(function (compilationTask) {\r\n            if (projectSpec.compilerOptions.out) {\r\n                compilationTask.out = path.normalize(projectSpec.compilerOptions.out).replace(/\\\\/g, '/');\r\n            }\r\n            if (projectSpec.compilerOptions.outFile) {\r\n                compilationTask.out = path.normalize(path.join(relativePathFromGruntfileToTSConfig(), projectSpec.compilerOptions.outFile)).replace(/\\\\/g, '/');\r\n            }\r\n            if (projectSpec.compilerOptions.outDir) {\r\n                compilationTask.outDir = path.normalize(path.join(relativePathFromGruntfileToTSConfig(), projectSpec.compilerOptions.outDir)).replace(/\\\\/g, '/');\r\n            }\r\n        });\r\n    }\r\n    return options;\r\n}\r\nfunction getTSConfigSettings(raw) {\r\n    try {\r\n        if (!raw || !raw.tsconfig) {\r\n            return null;\r\n        }\r\n        if (typeof raw.tsconfig === 'boolean') {\r\n            return {\r\n                tsconfig: path.join(path.resolve('.'), 'tsconfig.json')\r\n            };\r\n        }\r\n        else if (typeof raw.tsconfig === 'string') {\r\n            var tsconfigName = templateProcessor(raw.tsconfig, {});\r\n            var fileInfo = fs.lstatSync(tsconfigName);\r\n            if (fileInfo.isDirectory()) {\r\n                tsconfigName = path.join(tsconfigName, 'tsconfig.json');\r\n            }\r\n            return {\r\n                tsconfig: tsconfigName\r\n            };\r\n        }\r\n        if (!('tsconfig' in raw.tsconfig) &&\r\n            !raw.tsconfig.passThrough) {\r\n            raw.tsconfig.tsconfig = 'tsconfig.json';\r\n        }\r\n        return raw.tsconfig;\r\n    }\r\n    catch (ex) {\r\n        if (ex.code === 'ENOENT') {\r\n            throw ex;\r\n        }\r\n        var exception = {\r\n            name: 'Invalid tsconfig setting',\r\n            message: 'Exception due to invalid tsconfig setting.  Details: ' + ex,\r\n            code: ex.code,\r\n            errno: ex.errno\r\n        };\r\n        throw exception;\r\n    }\r\n}\r\nfunction applyCompilerOptions(applyTo, projectSpec) {\r\n    var result = applyTo || {}, co = projectSpec.compilerOptions, tsconfig = applyTo.tsconfig;\r\n    if (!tsconfig.ignoreSettings && co) {\r\n        // Go here for the tsconfig.json documentation:\r\n        // https://github.com/Microsoft/TypeScript-Handbook/blob/master/pages/tsconfig.json.md\r\n        // There is a link to http://json.schemastore.org/tsconfig\r\n        var sameNameInTSConfigAndGruntTS = [\r\n            'allowJs',\r\n            'allowSyntheticDefaultImports',\r\n            'allowUnreachableCode',\r\n            'allowUnusedLabels',\r\n            // we do not support charset as we assume input files are UTF-8.\r\n            'declaration',\r\n            'emitBOM',\r\n            'emitDecoratorMetadata',\r\n            'experimentalAsyncFunctions',\r\n            'experimentalDecorators',\r\n            'forceConsistentCasingInFileNames',\r\n            'isolatedModules',\r\n            'inlineSourceMap',\r\n            'inlineSources',\r\n            'jsx',\r\n            // we do not support listFiles.\r\n            'locale',\r\n            'mapRoot',\r\n            'module',\r\n            'moduleResolution',\r\n            'newLine',\r\n            'noEmit',\r\n            'noEmitHelpers',\r\n            'noEmitOnError',\r\n            'noFallthroughCasesInSwitch',\r\n            'noImplicitAny',\r\n            'noImplicitReturns',\r\n            'noImplicitUseStrict',\r\n            'noLib',\r\n            'noResolve',\r\n            'out',\r\n            'outDir',\r\n            // outFile is handled below.\r\n            'preserveConstEnums',\r\n            'pretty',\r\n            'reactNamespace',\r\n            'removeComments',\r\n            'rootDir',\r\n            'skipDefaultLibCheck',\r\n            'sourceMap',\r\n            'sourceRoot',\r\n            'stripInternal',\r\n            'suppressExcessPropertyIndexErrors',\r\n            'suppressImplicitAnyIndexErrors',\r\n            'target'\r\n        ];\r\n        sameNameInTSConfigAndGruntTS.forEach(function (propertyName) {\r\n            if ((propertyName in co) && !(propertyName in result)) {\r\n                result[propertyName] = co[propertyName];\r\n            }\r\n        });\r\n        // now copy the ones that don't have the same names.\r\n        // `outFile` was added in TypeScript 1.6 and is the same as out for command-line\r\n        // purposes except that `outFile` is relative to the tsconfig.json.\r\n        if (('outFile' in co) && !('out' in result)) {\r\n            result['out'] = co['outFile'];\r\n        }\r\n    }\r\n    if (!('updateFiles' in tsconfig)) {\r\n        tsconfig.updateFiles = true;\r\n    }\r\n    if (applyTo.CompilationTasks.length === 0) {\r\n        applyTo.CompilationTasks.push({ src: [] });\r\n    }\r\n    var src = applyTo.CompilationTasks[0].src;\r\n    absolutePathToTSConfig = path.resolve(tsconfig.tsconfig, '..');\r\n    if (tsconfig.overwriteFilesGlob) {\r\n        if (!gruntfileGlobs) {\r\n            throw new Error('The tsconfig option overwriteFilesGlob is set to true, but no glob was passed-in.');\r\n        }\r\n        var relPath = relativePathFromGruntfileToTSConfig(), gruntGlobsRelativeToTSConfig = [];\r\n        for (var i = 0; i < gruntfileGlobs.length; i += 1) {\r\n            gruntfileGlobs[i] = gruntfileGlobs[i].replace(/\\\\/g, '/');\r\n            gruntGlobsRelativeToTSConfig.push(path.relative(relPath, gruntfileGlobs[i]).replace(/\\\\/g, '/'));\r\n        }\r\n        if (_.difference(projectSpec.filesGlob, gruntGlobsRelativeToTSConfig).length > 0 ||\r\n            _.difference(gruntGlobsRelativeToTSConfig, projectSpec.filesGlob).length > 0) {\r\n            projectSpec.filesGlob = gruntGlobsRelativeToTSConfig;\r\n            if (projectSpec.files) {\r\n                projectSpec.files = [];\r\n            }\r\n            saveTSConfigSync(tsconfig.tsconfig, projectSpec);\r\n        }\r\n    }\r\n    if (tsconfig.updateFiles && projectSpec.filesGlob) {\r\n        if (projectSpec.files === undefined) {\r\n            projectSpec.files = [];\r\n        }\r\n        updateTSConfigAndFilesFromGlob(projectSpec.files, projectSpec.filesGlob, tsconfig.tsconfig);\r\n    }\r\n    if (projectSpec.files) {\r\n        addUniqueRelativeFilesToSrc(projectSpec.files, src, absolutePathToTSConfig);\r\n    }\r\n    else {\r\n        var validPattern_1 = /\\.tsx?$/i;\r\n        var excludedPaths_1 = [];\r\n        if (_.isArray(projectSpec.exclude)) {\r\n            excludedPaths_1 = projectSpec.exclude.map(function (filepath) {\r\n                return utils.makeRelativePath(absolutePathToTSConfig, path.resolve(absolutePathToTSConfig, filepath));\r\n            });\r\n        }\r\n        var files = utils.getFiles(absolutePathToTSConfig, function (filepath) {\r\n            return excludedPaths_1.indexOf(utils.makeRelativePath(absolutePathToTSConfig, filepath)) > -1\r\n                || (fs.statSync(filepath).isFile()\r\n                    && !validPattern_1.test(filepath));\r\n        }).map(function (filepath) {\r\n            return utils.makeRelativePath(absolutePathToTSConfig, filepath);\r\n        });\r\n        projectSpec.files = files;\r\n        if (projectSpec.filesGlob) {\r\n            saveTSConfigSync(tsconfig.tsconfig, projectSpec);\r\n        }\r\n        addUniqueRelativeFilesToSrc(files, src, absolutePathToTSConfig);\r\n    }\r\n    return result;\r\n}\r\nfunction relativePathFromGruntfileToTSConfig() {\r\n    if (!absolutePathToTSConfig) {\r\n        throw 'attempt to get relative path to tsconfig.json before setting absolute path';\r\n    }\r\n    return path.relative('.', absolutePathToTSConfig).replace(/\\\\/g, '/');\r\n}\r\nfunction updateTSConfigAndFilesFromGlob(filesRelativeToTSConfig, globRelativeToTSConfig, tsconfigFileName) {\r\n    if (globExpander.isStub) {\r\n        return;\r\n    }\r\n    var absolutePathToTSConfig = path.resolve(tsconfigFileName, '..');\r\n    var filesGlobRelativeToGruntfile = [];\r\n    for (var i = 0; i < globRelativeToTSConfig.length; i += 1) {\r\n        filesGlobRelativeToGruntfile.push(path.relative(path.resolve('.'), path.join(absolutePathToTSConfig, globRelativeToTSConfig[i])));\r\n    }\r\n    var filesRelativeToGruntfile = globExpander(filesGlobRelativeToGruntfile);\r\n    {\r\n        var filesRelativeToTSConfig_temp = [];\r\n        var relativePathFromGruntfileToTSConfig_1 = path.relative('.', absolutePathToTSConfig).replace(/\\\\/g, '/');\r\n        for (var i = 0; i < filesRelativeToGruntfile.length; i += 1) {\r\n            filesRelativeToGruntfile[i] = filesRelativeToGruntfile[i].replace(/\\\\/g, '/');\r\n            filesRelativeToTSConfig_temp.push(path.relative(relativePathFromGruntfileToTSConfig_1, filesRelativeToGruntfile[i]).replace(/\\\\/g, '/'));\r\n        }\r\n        filesRelativeToTSConfig.length = 0;\r\n        filesRelativeToTSConfig.push.apply(filesRelativeToTSConfig, filesRelativeToTSConfig_temp);\r\n    }\r\n    var tsconfigJSONContent = utils.readAndParseJSONFromFileSync(tsconfigFileName);\r\n    var tempTSConfigFiles = tsconfigJSONContent.files || [];\r\n    if (_.difference(tempTSConfigFiles, filesRelativeToTSConfig).length > 0 ||\r\n        _.difference(filesRelativeToTSConfig, tempTSConfigFiles).length > 0) {\r\n        try {\r\n            tsconfigJSONContent.files = filesRelativeToTSConfig;\r\n            saveTSConfigSync(tsconfigFileName, tsconfigJSONContent);\r\n        }\r\n        catch (ex) {\r\n            var error = new Error('Error updating tsconfig.json: ' + ex);\r\n            throw error;\r\n        }\r\n    }\r\n}\r\nfunction saveTSConfigSync(fileName, content) {\r\n    fs.writeFileSync(fileName, JSON.stringify(content, null, '    '));\r\n}\r\nfunction addUniqueRelativeFilesToSrc(tsconfigFilesArray, compilationTaskSrc, absolutePathToTSConfig) {\r\n    var gruntfileFolder = path.resolve('.');\r\n    _.map(_.uniq(tsconfigFilesArray), function (file) {\r\n        var absolutePathToFile = path.normalize(path.join(absolutePathToTSConfig, file));\r\n        var relativePathToFileFromGruntfile = path.relative(gruntfileFolder, absolutePathToFile).replace(new RegExp('\\\\' + path.sep, 'g'), '/');\r\n        if (compilationTaskSrc.indexOf(absolutePathToFile) === -1 &&\r\n            compilationTaskSrc.indexOf(relativePathToFileFromGruntfile) === -1) {\r\n            compilationTaskSrc.push(relativePathToFileFromGruntfile);\r\n        }\r\n    });\r\n}\r\n//# sourceMappingURL=tsconfig.js.map"}